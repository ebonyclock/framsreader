[
  {
    "name": "Make regular shapes",
    "_classname": "script",
    "code": "\n/**\nAuthor: Szymon Wojciechowski, MK \n \nThis scripts generates 4 kinds of regular shapes: a truss, a triangular or parallelogramic net, a sponge, and the Sierpinski's Pyramid.\nEach of these is parametrized so you can create a family of similar constructs - see the main() function.\n\nEach of these shapes is constructed from a basic module that is multiplied until the desired size is reached.\nExcept from trusses, shapes are built using vectors of Parts and Joints and dictionaries of Parts and Joints.\nThe dictionaries keep the index of each Joint or Part in the f0 genotype.\nThis information is used to join proper Parts, and to check if a specific Joint already exists.\n\n//TODO: tetrahedral mesh\n*/\n\nfunction main()\n{\n  var stif = 1.0;    // axial stiffness, 0..1\n  var rotstif = 1.0; // rotational stiffness, 0..1\n  \n  var sideSticks = 1; // length of the edge of the cube - used only for truss\n  var diagonal = 1; // 0 or 1. Diagonals are actually diagonals only when sideSticks==1, otherwise they are only cantilevers (their length is always sqrt(2)). \n  \n  // how many elements will the construction have in ...\n  var height = 3;\n  var depth = 3;\n  var width = 3;\n  \n  addSampleGenotype(createTruss(sideSticks, height, width, depth, diagonal, stif, rotstif));\n  addSampleGenotype(createTruss(sideSticks, 2, 2, 2, 0, stif, rotstif));\n  addSampleGenotype(createTruss(2, 0, 10, 10, 0, stif, rotstif));\n  addSampleGenotype(createTruss(4, 1, 1, 1, 1, stif, rotstif));\n  \n  addSampleGenotype(createSponge(height, width, depth, stif, rotstif)); \n  addSampleGenotype(createSponge(1, 5, 5, stif, rotstif));\n  addSampleGenotype(createSponge(1, 1, 1, stif, rotstif));\n  \n  addSampleGenotype(createSierpinskiPyramid(height, stif, rotstif)); \n  addSampleGenotype(createSierpinskiPyramid(4, stif, rotstif));\n  \n  var triangular = 0; // make triangular or parallelogramic net; 1 makes the net triangular, otherwise it will be parallelogramic\n  height = 10;\n  addSampleGenotype(createTriangularNet(height, triangular, stif, rotstif)); \n  addSampleGenotype(createTriangularNet(height, 1, stif, rotstif));\n}\n\n/** adds a genotype */\nfunction addSampleGenotype(genotype_and_name)\n{\n  var geno = Geno.newFromString(genotype_and_name[0]);\n  geno.name = genotype_and_name[1];\n  geno.info = \"A sample shape created by the 'regular_shapes.script' macro.\\nSee this macro for more possibilities.\"; \n  GenePools[0].add(geno);\n}\n\n\n/** fills the array with XYZ points with coordinates from coordinatesVector */\nfunction fillArray(coordinatesVector, array)\n{\n  var i;\n  for ( i = 0 ; i < coordinatesVector.size ; i += 3 )\n    array.add( XYZ.new ( coordinatesVector[i] , coordinatesVector[i + 1] , coordinatesVector[i + 2] ) );\n}\n\n/** fills the array with joint indexes from indexesVector */\nfunction fillJointArray(indexesVector, array)\n{\n  var i;\n  for ( i = 0 ; i < indexesVector.size ; i += 2 )\n    array.add([indexesVector[i], indexesVector[i + 1]]);\n}\n\n/** describes (shortly!) stif and rotstif to be included in genotype name */\nfunction describeStifs(stif, rotstif)\n{\n  return \" {\" + stif + \",\" + rotstif + \"}\";\n}\n\n/** makes the base of the sponge shape */\nfunction createSponge(height, width, depth, stif, rotstif)\n{\n  var name = \"createSponge(\" + height + \", \" + width + \", \" + depth + \")\" + describeStifs(stif, rotstif);\n  var points = Vector.new();\n  var joints = Vector.new();\n  var dict = Dictionary.new();\n  var jDict = Dictionary.new();\n  var i;\n\n  /** make the basic points */\n  var pointCoordinates = [0, 0, 0,\n                          0, 1, 0,\n                          1, 0, 0,\n                          0, 0, 1,\n                          1, 1, 0,\n                          1, 1, 1];\n\n  fillArray( pointCoordinates , points );\n\n  /** add points to the points dictionary */\n  for (i = 0 ; i < points.size ; i ++)\n    addPointToDict(dict, points[i], i + 1 );\n\n  /** make the basic joints */\n  var jointIndexes = [ 0, 1,\n                       1, 2,\n                       2, 3,\n                       3, 0,\n                       2, 0,\n                       1, 3,\n                       1, 4,\n                       2, 4,\n                       1, 5,\n                       2, 5,\n                       4, 5];\n\n  fillJointArray( jointIndexes , joints );\n\n  /** add joints to the joints dictionary */\n  for (i = 0 ; i < joints.size ; i ++)\n    addJointToDict(jDict, joints[i] );\n\n  /** make the bottom of the sponge shape */\n  makeBottomElement(points, joints, dict, jDict);\n\n  /** copy and rotate the basic element */\n  copyAndRotate(points, joints, dict, jDict, 90);\n  copyAndRotate(points, joints, dict, jDict, 180);\n\n  /** make regular shape by multiplying current element */\n  multiplyBase(height, width, depth, points, joints, dict, jDict);\n\n  /** make genotype from points and joints arrays */\n  return [makeGenoTypeFromArrays(points, joints, stif, rotstif), name];\n}\n\n/** multiplies basic sponge element */\nfunction multiplyBase(height, width, depth, points, joints, dict, jDict)\n{\n  var k, i;\n\n  /** for three dimensions */\n  for (k = 0 ; k < 3; k++)\n  {\n    var pBase = Vector.new();\n    var jBase = Vector.new();\n    var limit, movX, movY, movZ;\n\n    /** make copy for current dimensional multiplying base\n    at first dimension the base will be an element\n    at second level the base will be a line\n    at third level the base will be a surface\n    */\n    for (i = 0 ; i < points.size ; i++)\n      pBase.add( points[i].clone() );\n\n    for (i = 0 ; i < joints.size ; i++)\n      jBase.add( [joints[i][0], joints[i][1]] );\n\n    /** fill the current dimension variables */\n    switch (k)\n    {\n    case 0:\n      limit = width;\n      movX = 1;\n      movY = 0;\n      movZ = 0;\n      break;\n    case 1:\n      limit = depth;\n      movX = 0;\n      movY = 1;\n      movZ = 0;\n      break;\n    case 2:\n      limit = height;\n      movX = 0;\n      movY = 0;\n      movZ = 1;\n      break;\n    }\n\n\n    /** for current dimension size */\n    for (i = 1 ; i < limit ; i++)\n    {\n      var p = Vector.new();\n      var j;\n\n      var dX = movX * i * 2;\n      var dY = movY * i * 2;\n      var dZ = movZ * i;\n\n\n      /** copy current base points*/\n      for (j = 0 ; j < pBase.size ; j++)\n      {\n        p.add(addPoints( pBase[j].clone(), XYZ.new(dX, dY, dZ) ) );\n\n        if (getPointIndex(dict, p[j]) == null)\n        {\n          points.add(p[j]);\n          addPointToDict(dict, p[j], points.size);\n        }\n      }\n\n      /** copy current base joints */\n      var size = jBase.size;\n      for ( j = 0 ; j < size ; j++)\n      {\n        var joi = [ getPointIndex(dict, p[ jBase[j][0] ] ) - 1, getPointIndex(dict, p[ jBase[j][1] ] ) - 1 ];\n        if (ifJointExsits(jDict, joi) == null)\n        {\n          joints.add( joi );\n          addJointToDict(jDict, joi);\n        }\n      }\n    }\n  }\n}\n\n/** copies, rotates and joins a shape (provided as points) */\nfunction copyAndRotate(points, joints, dict, jDict, angle)\n{\n  var newPoints = Vector.new();\n  var s = points.size;\n  var i;\n  var pSize = points.size;\n\n  /** rotates the points */\n  for (i = 0 ; i < pSize ; i++)\n  {\n    /** rotate given point */\n    newPoints.add( rotate90or180(points[i], angle) );\n\n    /** add it to a dictionary */\n    if (getPointIndex(dict, newPoints[i]) == null)\n    {\n      points.add(newPoints[i]);\n      addPointToDict(dict, newPoints[i], points.size);\n    }\n  }\n\n  /** copy the joints for rotated points */\n  var size = joints.size;\n  for ( i = 0 ; i < size ; i++)\n  {\n    var j = [ getPointIndex(dict, newPoints[ joints[i][0] ] ) - 1, getPointIndex(dict, newPoints[ joints[i][1] ] ) - 1 ];\n    if (ifJointExsits(jDict, j) == null)\n    {\n      joints.add( j );\n      addJointToDict(jDict, j);\n    }\n  }\n}\n\n/** assures that -0.0 becomes 0.0, which is important because further comparisons (e.g. when used as a key in a dictionary) are made on the textual representation of floating point values */\nfunction fixSignedZero(v)\n{\n  if (v==0.0) return 0.0; else return v;\n}\n\n/** calculates point rotation; the angle parameter must be 90 or 180 only */\nfunction rotate90or180(point, angle)\n{\n  if (angle==90) return XYZ.new(fixSignedZero(-point.y),               point.x, point.z);\n            else return XYZ.new(fixSignedZero(-point.x),fixSignedZero(-point.y),point.z);\n}\n\n/** makes the sponge bottom element */\nfunction makeBottomElement(points, joints, dict, jDict)\n{\n  var p = XYZ.new(0, 1, -1);\n  points.add(p);\n  addPointToDict(dict, p, points.size );\n\n  p = XYZ.new(1, 0, -1);\n  points.add(p);\n  addPointToDict(dict, p, points.size );\n\n  var i, size = joints.size;\n\n  var jointIndexes = [1, 6,\n                      2, 7,\n                      6, 0,\n                      0, 4,\n                      6, 4,\n                      0, 7,\n                      7, 4];\n\n  fillJointArray( jointIndexes , joints);\n\n  for (i = size ; i < joints.size ; i++)\n    addJointToDict(jDict, joints[i] );\n}\n\n/** makes triangluar net */\nfunction createTriangularNet(height, triangular, stif, rotstif)\n{\n  var name = \"createTriangularNet(\" + height + \", \" + triangular + \")\" + describeStifs(stif, rotstif);\n  height++;\n  var points = Vector.new();\n  var joints = Vector.new();\n  var SQRT3 = Math.sqrt(3);\n  var left = XYZ.new(0, 0, 0);\n  points.add( left );\n\n  var pointsVectorLength = 0;\n  var i;\n\n  /** iteration on the net's height */\n  for (i = 2 ; i <= height ; i++)\n  {\n    var size = points.size;\n    var first = XYZ.new(left.x - 0.5, left.y - (SQRT3 / 2), 0);\n    points.add(first);\n    joints.add( [ size, size - (i - 1) ] );\n\n    left = first;\n\n    var j;\n    var pPrevious = left;\n\n    /** fills the curent level of the net */\n    for (j = 1; j < i ; j++)\n    {\n      var curr = XYZ.new( pPrevious.x + 1, pPrevious.y, 0);\n      points.add(curr);\n      joints.add( [ size + j, size + j - 1 ] );\n      joints.add( [ size + j, size + j - i ] );\n\n      if (triangular == 1 && j != i - 1)\n      {\n        joints.add( [ size + j, size + j - i + 1 ] );\n      }\n\n      pPrevious = curr;\n    }\n  }\n\n  return [makeGenoTypeFromArrays(points, joints, stif, rotstif), name];\n}\n\nfunction getKeyForJointPair(jointpair)\n{\n  var x = jointpair[0];\n  var y = jointpair[1];\n\n  if (x < y) //smaller first\n    return \"\" + x + \";\" + y;\n  else\n\t  return \"\" + y + \";\" + x;\n}\n\nfunction addIfNotExists(dict, key, val)\n{\n  if (dict[key] == null) //does not exist?\n    dict.set(key, val);\n}\n\n\n/** adds joint to joints dictionary */\nfunction addJointToDict(dict, joint)\n{\n  var key = getKeyForJointPair(joint);\n  addIfNotExists(dict, key, 1);\n}\n\n/** checks if the joint exists in the dictionary */\nfunction ifJointExsits(dict, joint)\n{\n  var key = getKeyForJointPair(joint);\n  return dict[key]; //null or value, if exists\n}\n\n/** adds the point to the dictionary with the given index number */\nfunction addPointToDict(dict, point, index)\n{\n  var key = \"\" + point.x + \";\" + point.y +\";\" + point.z;\n  addIfNotExists(dict, key, index);\n}\n\n/** gets the given point index from the points dictionary; also checks if the point exists */\nfunction getPointIndex(dict, point)\n{\n  var key = \"\" + point.x + \";\" + point.y +\";\" + point.z;\n  return dict[key]; //null or value, if exists\n}\n\n/** makes a next level of Sierpinski's Pyramid */\nfunction makeNextLevel(dictionary, points, joints)\n{\n  var newPoints = Vector.new();\n  newPoints.add(Vector.new());\n  newPoints.add(Vector.new());\n  newPoints.add(Vector.new());\n  var i, j;\n  var index = points.size + 1;\n  var size = points.size;\n\n  var keys = [\"L\", \"R\", \"C\" ];\n\n  /** copies the current pyramid and moves it 3 times on the bottom*/\n  for (j = 0 ; j < 3 ; j++)\n  {\n    var key = keys[j];\n\n    for ( i = 0 ; i < size ; i++)\n    {\n      var p1 = points[i].clone();\n\n      /** moves the copy of point to the right place on the bottom copy */\n      newPoints[j].add( addPoints(p1, dictionary[key]) );\n\n      /** adds an unexisting point */\n      if (getPointIndex(dictionary, newPoints[j][i]) == null)\n      {\n        addPointToDict(dictionary, newPoints[j][i], index);\n        points.add(newPoints[j][i]);\n        index++;\n      }\n    }\n  }\n\n  var newJoints = Vector.new();\n  for (j = 0 ; j < 3 ; j++)\n  {\n    newJoints.add(Vector.new());\n  }\n\n  /** makes new joints */\n  for (j = 0 ; j < 3 ; j++)\n  {\n    for (i = 0; i < joints.size ; i++)\n    {\n      newJoints[j].add( [ getPointIndex(dictionary, newPoints[j][joints[i][0]] ) - 1 , getPointIndex(dictionary, newPoints[j][joints[i][1]] ) - 1 ] );\n    }\n  }\n\n  size = joints.size;\n\n  /** adds new joints */\n  for (j = 0 ; j < 3 ; j++)\n  {\n    for ( i = 0 ; i < size ; i++)\n    {\n      joints.add(newJoints[j][i]);\n    }\n  }\n\n  /** change the new movement vectors */\n  for (j = 0 ; j < 3 ; j++)\n  {\n    dictionary.set(keys[j], addPoints(dictionary[keys[j]].clone(), dictionary[keys[j]] ));\n  }\n\n}\n\n/** adds the second parameter point to the first parameter point */\nfunction addPoints(p1, p2)\n{\n  p1.x += p2.x;\n  p1.y += p2.y;\n  p1.z += p2.z;\n  return p1;\n}\n\n/** creates the base of Sierpinski's Pyramid */\nfunction createSierpinskiPyramid(height, stif, rotstif)\n{\n  var name = \"createSierpinskiPyramid(\" + height + \")\" + describeStifs(stif, rotstif);\n  var SQRT2 = Math.sqrt(2);\n  var dict = Dictionary.new();\n  var points = Vector.new();\n  var joints = Vector.new();\n  var i, j;\n\n  /** base triangle coordinates */\n  var pointCoordinates = [0, 0, 0];\n  for (i = 0 ; i < 3 ; i++)\n    for (j = 0 ; j < 3 ; j++)\n      if (i == j)\n        pointCoordinates.add(0);\n      else\n        pointCoordinates.add(1);\n\n  fillArray( pointCoordinates , points );\n\n  /** add points to the points dictionary */\n  for (i = 0 ; i < points.size ; i ++)\n    addPointToDict(dict, points[i], i + 1 );\n\n  /** possible new element movement */\n  var tab = [\"L\", \"R\", \"C\"];\n  for (i = 0 ; i < 3 ; i++)\n    dict.set(tab[i], points[i + 1]);\n\n  /** base joints coordinates */\n  var jointIndexes = [1, 0,\n                      2, 3,\n                      2, 0,\n                      3, 1,\n                      2, 1,\n                      3, 0];\n\n  fillJointArray( jointIndexes , joints );\n\n  /** make additional levels */\n  for (i = 0 ; i < height ; i++)\n  {\n    makeNextLevel(dict, points, joints);\n  }\n\n  return [makeGenoTypeFromArrays(points, joints, stif, rotstif), name];\n}\n\n/** encodes property value as a string, ready to be added to the f0 genotype */\nfunction encodePropertyInF0(name, value, defaultvalue)\n{\n    if (value == defaultvalue) //is default value?\n      return \"\"; //then no need to specify.\n    else\n      return \",\" + name + \"=\" + value;\n}\n\n/** generates f0 gene that describes one joint */\nfunction makeJoint(index1, index2, stif, rotstif)\n{\n  return \"j:\" + index1 + \",\" + index2 + encodePropertyInF0(\"stif\", stif, 1.0) + encodePropertyInF0(\"rotstif\", rotstif, 1.0) + \"\\n\";\n}\n\n/** converts points and joints arrays into a genotype; also adds stif and rotstif values */\nfunction makeGenoTypeFromArrays(points, joints, stif, rotstif)\n{\n  var pSize = points.size;\n  var jSize = joints.size;\n  var str = \"//0\\n\";\n\n  var i, elem;\n  for (i = 0 ; i < pSize ; i++)\n  {\n    elem = points[i];\n    str += \"p:\" + elem.x + \",\" + elem.y + \",\" + elem.z + \"\\n\";\n  }\n\n  for (i = 0 ; i < jSize ; i++)\n  {\n    elem = joints[i];\n    str += makeJoint(elem[0], elem[1], stif, rotstif);\n  }\n\n  return str;\n}\n\n/** makes the truss construction */\nfunction createTruss(sideSticks, height, width, depth, diagonal, stif, rotstif)\n{\n  var name = \"createTruss(\" + sideSticks + \", \" + height + \", \" + width + \", \" + depth + \", \" + diagonal + \")\" + describeStifs(stif, rotstif);\n\n  var i = sideSticks * depth;\n  var j = sideSticks * width;\n  var k = sideSticks * height;\n\n  var ii, jj, kk;\n  var v3d = Vector.new();\n  var index = 1;\n  var str = \"//0\\n\";\n\n\n  /** for height dimension */\n  for (kk = 0 ; kk <= k ; kk++)\n  {\n    var v2d = Vector.new();\n    /** for depth dimension */\n    for ( ii = 0; ii <= i ; ii++)\n    {\n      var v1d = Vector.new();\n      /** for width dimension */\n      for ( jj = 0; jj <= j ;jj++)\n      {\n        var temp = 0;\n\n        /** current point is a truss element */\n        if ( ((jj % sideSticks) == 0 && (ii % sideSticks) == 0) || ((kk % sideSticks) == 0 && (ii % sideSticks) == 0) || ((jj % sideSticks) == 0 && (kk % sideSticks) == 0) )\n        {\n          temp = index;\n          v1d.add(index);\n          index++;\n        }\n        else\n          v1d.add(0);\n\n        /** make current point connections */\n        if ( temp != 0)\n        {\n          str += \"p:\" + ii + \",\" + jj + \",\" + kk + \"\\n\";\n\n          /** make side element connections */\n          var s;\n          for ( s = 0 ; s < 3 ; s++)\n          {\n            var neighbor = 0;\n            switch (s)\n            {\n            case 0:\n              if ( kk - 1 >= 0)\n                neighbor = v3d[kk - 1][ii][jj];\n              break;\n            case 1:\n              if ( ii - 1 >= 0)\n                neighbor = v2d[ii - 1][jj];\n              break;\n            case 2:\n              if ( jj - 1 >= 0)\n                neighbor = v1d[jj - 1];\n              break;\n            }\n            if (neighbor != 0)\n            {\n              str += makeJoint(temp - 1,neighbor - 1, stif, rotstif);                 \n            }\n          }\n\n          /** make diagonals */\n          if (diagonal == 1)\n          {\n            var s;\n            for (s = 0 ; s < 10 ; s++) // make cuboid diagonals\n            {\n              var neighbor = 0;\n              switch (s)\n              {\n              case 0:\n                if (jj - 1 >= 0 && ii - 1 >= 0 && kk - 1 >= 0) // 1st cube diagnal\n                  neighbor = v3d[kk - 1][ii - 1][jj - 1];\n                break;\n              case 1:\n                if (jj - 1 >= 0 && ii + 1 <= i && kk - 1 >= 0) // 2nd cube diagnal\n                  neighbor = v3d[kk - 1][ii + 1][jj - 1];\n                break;\n              case 2:\n                if (jj + 1 <= j && ii - 1 >= 0 && kk - 1 >= 0) // 3rd cube diagnal\n                  neighbor = v3d[kk - 1][ii - 1][jj + 1];\n                break;\n              case 3:\n                if (jj + 1 <= j && ii + 1 <= i && kk - 1 >= 0) // 4th cube diagnal\n                  neighbor = v3d[kk - 1][ii + 1][jj + 1];\n                break;\n              case 4:\n                if (jj - 1 >= 0 && ii - 1 >= 0) // 1st side diagonal\n                  neighbor = v2d[ii - 1][jj - 1];\n                break;\n              case 5:\n                if (kk - 1 >= 0 && ii - 1 >= 0) // 2nd side diagonal\n                  neighbor = v3d[kk - 1][ii - 1][jj];\n                break;\n              case 6:\n                if (jj - 1 >= 0 && kk - 1 >= 0) // 3rd side diagonal\n                  neighbor = v3d[kk - 1][ii][jj - 1];\n                break;\n              case 7:\n                if (jj + 1 <= j && ii - 1 >= 0) // 4th side diagonal\n                  neighbor = v2d[ii - 1][jj + 1];\n                break;\n              case 8:\n                if (kk - 1 >= 0 && ii + 1 <= i) // 5th side diagonal\n                  neighbor = v3d[kk - 1][ii + 1][jj];\n                break;\n              case 9:\n                if (jj + 1 <= j && kk - 1 >= 0) // 6th side diagonal\n                  neighbor = v3d[kk - 1][ii][jj + 1];\n                break;\n              }\n              if (neighbor != 0)\n              {\n                str += makeJoint(temp - 1,neighbor - 1, stif, rotstif);                                              \n              }\n            }\n          }\n        }\n\n      }\n      v2d.add(v1d);\n    }\n    v3d.add(v2d);\n  }\n\n  return [str, name];\n}\n",
    "help": "Make regular shapes (truss, sponge, grid, net)"
  }
]