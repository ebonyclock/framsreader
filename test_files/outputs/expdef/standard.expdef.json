[
  {
    "name": "Evolutionary optimization (steady-state)",
    "_classname": "expdef",
    "info": "This experiment definition can be used to perform a range of common experiments. It provides\n\n- one gene pool\n- one population for individuals\n- one \"population\" for food\n- steady-state evolutionary optimization\n- fitness as a weighted sum of performance values\n- or custom fitness formulas\n- fitness scaling\n- selection: roulette or tournament\n- multiple evaluation option, average and standard deviation available\n- can produce logs with average and best fitness\n- can detect stagnation and stop automatically\n- can save best genotypes\n",
    "code": "\nglobal g_evaluated_genotype; //genotype uid for multiple evaluation mode\nglobal g_bestsofar; //last best\nglobal g_bestsofarnr; //last best time\nglobal g_uniquename; //used to save experiment files\n\nfunction onExpDefLoad()\n{\n\t// define genotype and creature groups\n\tGenePools[0].name = \"Genotypes\";\n\tExpProperties.cr_v = 1;\n\tupdate_fitformula();\n\n\tvar p = Populations[0];\n\tp.name = \"Creatures\";\n\tp.nnsim = 2;\n\tp.enableperf = 2;\n\tp.selfmask = 0x10001;\n\tp.othermask = 0x20001;\n\n\tp = Populations.addGroup(\"Food\");\n\tp.nnsim = 0;\n\tp.enableperf = 0;\n\tp.selfmask = 0x20002;\n\tp.othermask = 0x10002;\n\n\tg_bestsofarnr = -1;\n\tg_uniquename = \"notinited\";\n}\n\nfunction onExpInit()\n{\n\tPopulations[0].clear();\n\tPopulations[1].clear();\n\tGenePools[0].clear();\n\tGenePools[0].add(ExpProperties.initialgen);\n\tExpState.totaltestedcr = 0;\n\tExpState.totaltests = 0;\n\n\tg_evaluated_genotype = null;\n\tg_bestsofarnr = -1;\n\tg_uniquename = String.format(\"%06d\", Math.time % 1000000) + String.format(\"%02d\", (Math.time % 1) * 100);\n\tif (ExpProperties.log > 0)\n\t{\n\t\tvar unchanged;\n\t\tif (ExpProperties.evalcount > 0)\n\t\t\tunchanged = \"\" + ExpProperties.evalcount + \"x \";\n\t\telse\n\t\t\tunchanged = \"\" + ExpProperties.p_nop + \",\";\n\t\tSimulator.print(\"[LOGTITLE] \" + [\"MECHA\", \"ODE\"][World.simtype] + \" rnd=(\" +\n\t\t                sim_params.bnoise_struct + \",\" + sim_params.bnoise_vel + \",\" + sim_params.randinit +\n\t\t                \") popsize=\" + ExpProperties.capacity +\n\t\t                \" gen.ops.=(\" + unchanged + ExpProperties.p_mut + \",\" + ExpProperties.p_xov + \")\");\n\t}\n}\n\n@include \"standard_placement.inc\"\n\nfunction creatureNumJointsForEnergy(cr)\n{\n\tvar n = cr.numjoints;\n\tif (n == 0)\n\t\tn = cr.numparts; //creatures with only one Part will live just as long as one-stick creatures\n\treturn n;\n}\n\nfunction onBorn(cr)\n{\n\tconst TRIALS = 50; //try to find free place 50 times\n\tvar retry = TRIALS;\n\n\t/* if you want to rotate a creature differently each time it is evaluated during \"multiple evaluation\"\n\tif (ExpProperties.evalcount == 6)\n\t{\n\t  //different rotation in each of the multiple evaluations: none, left, right, forth, back, upside-down\n\t  var rotationsx = [0, 0,        0,         Math.pi2, -Math.pi2, 2.0*Math.pi2];\n\t  var rotationsy = [0, Math.pi2, -Math.pi2, 0,        0,         0];\n\t  var extrarotate = ExpState.totaltests % 6;\n\t  cr.rotate(rotationsx[extrarotate],rotationsy[extrarotate],0);\n\t}*/\n\n\tvar placed_ok = 0;\n\twhile (retry--)\n\t{\n\t\tvar trycentral = (ExpProperties.placement == 1) && (retry == TRIALS - 1); //place central only in the first trial\n\t\tplaceCreatureRandomly(cr, trycentral, ExpProperties.rotation);\n\t\tif (!cr.boundingBoxCollisions(0))\n\t\t{\n\t\t\tplaced_ok = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!placed_ok)\n\t\tSimulator.message(\"onBorn() could not avoid collisions.\", 1);\n\n\tif (cr.population.index == 0)\n\t{\n\t\t// creature\n\t\tvar n = creatureNumJointsForEnergy(cr);\n\t\tcr.idleen = ExpProperties.e_meta * n;\n\t\tcr.energy0 = cr.energy0 * ExpProperties.Energy0 * n;\n\t\tcr.energy = cr.energy0;\n\t}\n\telse\n\t{\n\t\t// food\n\t\tcr.name = \"Food\";\n\t\tcr.idleen = 0;\n\t\tcr.energy0 = ExpProperties.feede0;\n\t\tcr.energy = cr.energy0;\n\t}\n}\n\nfunction addfood()\n{\n\tif (ExpProperties.foodgen == \"\")\n\t\treturn Populations[1].add(\"//0\\nm:Vstyle=food\\np:\");\n\telse\n\t\treturn Populations[1].add(ExpProperties.foodgen);\n}\n\nfunction onStep()\n{\n\tif (Populations[0].size < ExpProperties.MaxCreated)\n\t{\n\t\tif (GenePools[0].size == 0)\n\t\t{\n\t\t\tSimulator.stop();\n\t\t\tSimulator.message(\"This experiment is designed to build creatures from genotypes, but the GenePool is empty.\", 2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar g = selectGenotype();\n\t\t\t//Simulator.print(\"g=\"+g);\n\t\t\tif (g)\n\t\t\t{\n\t\t\t\tif (g.is_valid)\n\t\t\t\t\tPopulations[0].add(g);\n\t\t\t\telse\n\t\t\t\t\tSimulator.message(\"invalid genotype - ignored: \" + g.info, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSimulator.message(\"no genotype selected\", 1);\n\t\t}\n\t}\n\n\tif (ExpProperties.aging > 0)\n\t{\n\t\tfor(var cr in Populations[0])\n\t\t\tcr.idleen = ExpProperties.e_meta * creatureNumJointsForEnergy(cr)\n\t\t\t            * Math.exp((0.6931471806 * cr.steps_in_lifespan) / ExpProperties.aging);\n\t}\n\n\tif (Populations[1].size < ExpProperties.feed)\n\t\taddfood();\n}\n\n\nfunction saveGenotype(genotype, filename, description, append)\n{\n\tvar f;\n\tif (append)\n\t\tf = File.appendDirect(filename, description);\n\telse\n\t\tf = File.createDirect(filename, description);\n\tf.writeNameObject(\"org\", genotype);\n\tf.close();\n}\n\n\n\nglobal g_eval_again; //just to detect if some genotype is evaluated once again (and how much its average fitness varies from evaluation to evaluation even when they are repeated)\n\n// returns Genotype object that was updated or created from cr\nfunction updatePerformanceWithPopSize(cr)\n{\n\tvar GROUP_IDENTICAL_GENOTYPES = 1; //do you want identical genotypes to be grouped as one Genotype object (with instances>1 and averaged performances)?\n\tvar g = null;\n\tif (GROUP_IDENTICAL_GENOTYPES)\n\t\tg = GenePools[0].findGenotype(cr.geno); //will be either null (if no cr.geno exists in GenePools[0]) or some existing Genotype\n\n\tif (g == null) //cr.geno not found, which means that we have to add a new Genotype\n\t{\n\t\tg = Genotype.newFromCreature(cr);\n\t\tg.num = 0; // 0 = it will be filled automatically\n\t\tg.moveTo(GenePools[0]);\n\t\tg.instances = 0;\n\t}\n\n\tif (ExpProperties.evalcount > 0) //multiple evaluation\n\t{\n\t\tif (typeof(g.data->multieval) != \"Vector\") //first evaluation or other, rare cases (e.g. mutation produced an already existing genotype)\n\t\t{\n\t\t\tif (g.data->multieval != null) g_eval_again = g.fit2; //was already evaluated! let's see how much its average fitness varies\n\t\t\tg.data->multieval = [];\n\t\t}\n\t\tg.instances = g.data->multieval.size;\n\t}\n\n\t// Want to copy customized values from Creature data fields to Genotype data fields? Do it here: g.data->myfield = cr.data->myfield;\n\t// Want to take instances into account? Do it here: g.data->myfield = (float(g.data->myfield) * g.instances + cr.data->myfield) / (g.instances + 1);\n\tg.addPerformanceFromCreature(cr); //averages performances of \"g\" according to instances and increments instances\n\n\t//multiple evaluation - tricks to compute stddev of fitness and to detect if the same genotype has been multiply evaluated in the past:\n\tif (ExpProperties.evalcount > 0)\n\t{\n\t\tif (g_evaluated_genotype != null && GenePools[0].findUID(g_evaluated_genotype) < 0)\n\t\t\tg_evaluated_genotype = null; //evaluated genotype was lost\n\t\tif (g_evaluated_genotype == null)\n\t\t\tg_evaluated_genotype = g.uid;\n\t\tg.data->multieval.add(g.fit * g.instances - g.data->multieval.avg * g.data->multieval.size); //restore (and append to the data->multieval vector) original fitness from Genotype.fit's incremental average which is fit1, (fit1+fit2)/2, (fit1+fit2+fit3)/3, ...\n\t\tif (g.data->multieval.size < ExpProperties.evalcount)\n\t\t{\n\t\t\tg.instances = 0; //keep instances 0 (\"has no fitness\") until evaluated as many times as required\n\t\t\tExpState.totaltestedcr--; //don't count individual evaluations, increment only after ExpProperties.evalcount evaluations\n\t\t}\n\t\telse\n\t\t{\n\t\t\tg_evaluated_genotype = null; //no more evaluations needed for this one\n\t\t\tg.data->multieval = g.data->multieval.stdev; //compute std.dev. for a vector of fitness values\n\t\t\tg.instances = 1;\n\t\t\tif (g_eval_again != null)\n\t\t\t{\n\t\t\t\tSimulator.print(\"Another multiple evaluation of '\" + g.name + \"': previous average fitness was \" + g_eval_again + \", now changed by \" + (g.fit2 - g_eval_again));\n\t\t\t\tg_eval_again = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t//may be useful: save (append) all dying genotypes to a log file\n\t//if (ExpProperties.evalcount == 0 || (ExpProperties.evalcount > 0 && Genotype.instances == 1)) //no multiple evaluation: save all. multiple evaluation: save only when evaluation complete\n\t//  saveSelectedGenotype(g_uniquename + \"_died.gen\", \"Those who died\", 1);\n\n\t//extras:\n\tvar improvement = GenePools[0].genotype_instances > 0 && (g_bestsofarnr == -1 || stats.st_max_fit2 > g_bestsofar);\n\tvar logevery = [-1, 0, 1, 10, 100, 1000][ExpProperties.log];\n\tvar log = logevery == 0 && improvement; //either improved\n\tif (logevery > 0) //or periodic log\n\t\tif (ExpState.totaltestedcr % logevery == 0 || g_bestsofarnr == -1)\n\t\t\tlog = 1; //always log the first step\n\tif (ExpProperties.evalcount > 0 && (g_evaluated_genotype != null))\n\t\tlog = 0; //avoid multiple logs on subsequent evaluations of the same genotype\n\tif (improvement)\n\t{\n\t\tvar ratio; //bigger improvement -> higher and longer sound (max. 0.1 sec for >=2x improvement)\n\t\tif (g_bestsofarnr == -1 || g_bestsofar <= 0 || Math.abs(g_bestsofar) < 0.001)\n\t\t\tratio = 0.01;\n\t\telse\n\t\t\tratio = (stats.st_max_fit2 / g_bestsofar - 1) / 10;\n\t\tif (ratio < 0.01)\n\t\t\tratio = 0.01;\n\t\telse if (ratio > 0.1)\n\t\t\tratio = 0.1;\n\t\tif (ExpProperties.makesound)\n\t\t\tSimulator.sound(2000.0 + 10000.0 * ratio, 1000.0 * ratio);\n\t\tg_bestsofar = stats.st_max_fit2;\n\t\tg_bestsofarnr = ExpState.totaltestedcr;\n\t\tif (ExpProperties.savebest == 1)\n\t\t\tsaveGenotype(g, g_uniquename + \".gen\", \"Improvement snapshot\", 0);\n\t\tif (ExpProperties.savebest == 2)\n\t\t\tsaveGenotype(g, g_uniquename + \".gen\", \"Improvement snapshot\", 1);\n\t\tif (ExpProperties.savebest == 3)\n\t\t\tSimulator.save(g_uniquename + \".expt\");\n\t}\n\tvar stagnation = ExpProperties.stagnation > 0 && g_bestsofar > ExpProperties.minfitness && ExpState.totaltestedcr > g_bestsofarnr + ExpProperties.stagnation;\n\tif (log || (logevery >= 0 && stagnation))\n\t\tSimulator.print(\"[LOG] \" + ExpState.totaltestedcr + \" \" + GenePools[0].size + \" \" + stats.st_min_fit2 + \" \" + stats.st_avg_fit2 + \" \" + stats.st_max_fit2);\n\tif (stagnation) //ExpProperties.stagnation of non-improving evaluations stops.\n\t{\n\t\tvar mesg = \"stagnation detected (\" + ExpProperties.stagnation + \") at \" + ExpState.totaltestedcr + \" evals, best fitness = \" + g_bestsofar + \", \";\n\t\tif (ExpProperties.boostphase && ExpProperties.delrule != 2)\n\t\t{\n\t\t\tmesg += \"starting boost phase.\";\n\t\t\tExpProperties.delrule = 2;\n\t\t\tExpProperties.evalcount *= 2;\n\t\t\tg_bestsofarnr = ExpState.totaltestedcr; //start stagnation detection again\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmesg += \"stopping.\";\n\t\t\tif (ExpProperties.makesound)\n\t\t\t\tSimulator.sound(300, 200);\n\t\t\tSimulator.stop();\n\t\t}\n\t\tSimulator.print(mesg);\n\t}\n\n\treturn g;\n}\n\n//returns Genotype object that was updated or created from cr (used by standard-background.expdef)\nfunction onDied(cr)\n{\n\t//Simulator.print(\"on died cr=\"+cr+\" group=\"+cr.population.name+\" (#\"+cr.population.index+\")\");\n\tvar g = null;\n\tif (cr.population.index != 0)\n\t\treturn null; // ignore food\n\tif (cr.perf != 2)\n\t{\n\t\tExpState.totaltestedcr++;\n\t\tExpState.totaltests++;\n\t\tg = updatePerformanceWithPopSize(cr);\n\t}\n\telse   //the creature was killed before stabilization\n\t{\n\t\tif (ExpProperties.evalcount > 0) g_evaluated_genotype = null; //so don't try to evaluate it anymore. TODO seems that multiple evaluation mode does not handle this properly (this situation increases genotype count in group)\n\t}\n\tLimitGenePool();\n\tSimulator.checkpointData(ExpState.totaltestedcr);\n\treturn g;\n}\n\n@include \"standard_select.inc\"\n\nfunction selectGenotype() //returns Genotype object\n{\n\tvar sel, nop;\n\tif (ExpProperties.evalcount > 0)\n\t{\n\t\tif (g_evaluated_genotype != null)\n\t\t{\n\t\t\tvar gg = GenePools[0].findUID(g_evaluated_genotype);\n\t\t\tif (gg < 0)\n\t\t\t\tg_evaluated_genotype = null;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (GenePools[0][gg].data->multieval.size < ExpProperties.evalcount)\n\t\t\t\t{\n\t\t\t\t\treturn GenePools[0][gg];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (g_evaluated_genotype == null)\n\t\t\tnop = 0.0; //wanted a new mutation/xover to evaluate\n\t}\n\telse\n\t\tnop = ExpProperties.p_nop;\n\tvar sum = nop + ExpProperties.p_mut + ExpProperties.p_xov;\n\tsel = sum * Math.rnd01;\n\t//Simulator.print(\"sum=\"+sum+\" sel=\"+sel+\" nop=\"+nop+\" mut=\"+ExpProperties.p_mut+\" xov=\"+ExpProperties.p_mut);\n\tif (sel < nop || sum == 0)\n\t{\n\t\t//Simulator.print(\"selectGeno - nop\");\n\t\tvar selected = selectedForCreationInPool(GenePools[0]);\n\t\tif (selected)\n\t\t\treturn selected;\n\t\telse\n\t\t\treturn null;\n\t}\n\telse\n\t{\n\t\tsel = sel - nop;\n\t\tif (sel < ExpProperties.p_mut)\n\t\t{\n\t\t\t// Simulator.print(\"selectGeno - mutate\");\n\t\t\tvar selected = selectedForCreationInPool(GenePools[0]);\n\t\t\tif (selected)\n\t\t\t{\n\t\t\t\tvar g = Genotype.newFromGeno(GenMan.mutate(selected.geno));\n\t\t\t\tg.gnum = selected.gnum + 1; //generation\n\t\t\t\treturn g;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar other;\n\t\t\tvar first = selectedForCreationInPool(GenePools[0]);\n\t\t\tif (ExpProperties.xov_mins > 0.0)\n\t\t\t\tother = selectedSimilarInPool(GenePools[0]);\n\t\t\telse\n\t\t\t\tother = selectedForCreationInPool(GenePools[0]);\n\t\t\t// Simulator.print(\"selectGeno - xover - first=\"+first+\" other=\"+other);\n\t\t\tif ((first != null) && (other != null))\n\t\t\t{\n\t\t\t\tvar g = Genotype.newFromGeno(GenMan.crossOver(first.geno, other.geno));\n\t\t\t\tg.gnum = Math.max(first.gnum, other.gnum) + 1; //generation\n\t\t\t\treturn g;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSimulator.print(\"crossover - second genotype not found?\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction onFoodCollision()\n{\n\tvar e = Collision.Part2.ing * ExpProperties.feedtrans;\n\t//Simulator.print(\"transferring \"+e+\" from \"+Collision.Creature1.name+\" to \"+Collision.Creature2.name);\n\tCollision.Creature1.transferEnergyTo(Collision.Creature2, e);\n}\n\nfunction ExpProperties_cleardata_call()\n{\n\tfor(var g in GenePools[0])\n\t\tg.instances = 0;\n\tSimulator.print(\"Performance data reset.\");\n}\n\nfunction LimitGenePool()\n{\n\tvar pool = GenePools[0];\n\tif (pool.genotype_instances > (ExpProperties.capacity + 1)) // if removing more than 1\n\t\tSimulator.print(\"Removing \" + (pool.genotype_instances - ExpProperties.capacity) + \" genotype instances\");\n\twhile (pool.genotype_instances > ExpProperties.capacity)\n\t\tselectedForDeletionInPool(pool).deleteOne();\n}\n\nfunction ExpProperties_capacity_set()\n{\n\tLimitGenePool();\n}\n\nfunction limitPopulation(pop, n)\n{\n\tn = pop.size - n;\n\twhile (n > 0)\n\t{\n\t\tpop.delete(pop.size - 1);\n\t\tn--;\n\t}\n}\n\nfunction ExpProperties_MaxCreated_set()\n{\n\tlimitPopulation(Populations[0], ExpProperties.MaxCreated); //creatures\n}\n\nfunction ExpProperties_feed_set()\n{\n\tlimitPopulation(Populations[1], ExpProperties.feed); //food\n}\n\n@include \"standard_fitformula.inc\"\n@include \"standard_events.inc\"\n@include \"standard_loadsave.inc\"\n\n"
  },
  {
    "id": "cleardata",
    "_classname": "property",
    "help": "Sets the number of instances of each genotype to zero (as if it has never been evaluated).\nGenotype performance values stay intact, yet they are meaningless if a genotype has no instances.",
    "type": "p",
    "name": "Clear performance info"
  },
  {
    "id": "notes",
    "_classname": "state",
    "help": "You can write anything here\n(it will be saved to the experiment file)",
    "type": "s 1",
    "name": "Notes"
  },
  {
    "id": "totaltestedcr",
    "flags": 16,
    "help": "Total number of creatures evaluated in the experiment",
    "name": "Evaluated creatures",
    "_classname": "state",
    "type": "d"
  },
  {
    "id": "totaltests",
    "flags": 16,
    "help": "Total number of evaluations in the experiment.\nThis is equivalent to \"Evaluated creatures\" unless multiple evaluation is activated.",
    "name": "Number of evaluations",
    "_classname": "state",
    "type": "d"
  },
  {
    "id": "creaturesgrouploaded",
    "_classname": "state",
    "flags": 34,
    "type": "d",
    "name": "creaturesgrouploaded"
  }
]