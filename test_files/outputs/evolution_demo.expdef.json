[
  {
    "code": "\n/*\nAuthor: Marcin Szelag\nSupervisor: Maciej Komosinski\nCreated: January-March 2005\nUpdates: SzU, MK\nLast updated: 2015\n\nTechnical info:\n- one gene pool\n- one population with individuals, of given size\n- all genotypes from gene pool are visualized in the world - corresponding creatures stay in a circle\n- visualization for copying, mutating and crossing over genotypes\n- a few predefined well-observed fitnesses (vertical position, velocity, body size)\n- no energy flow calculation\n- creatures die after defined number of steps\n- experiment state saving / loading possible\n\nIf you wish to change experiment parameters, be aware that for some parameters you need to do this before experiment initialization.\nRead tooltip help for parameters of interest for more information.\n*/\n\n//TODO this expdef needs to be rewritten from stratch - it is way too complicated! Use the \"data\" dictionary in Creature's to keep all required data; avoid complex global structures.\n//TODO - alternative layout (e.g. creatures in a line, sorted from best to worst)\n\n//================================================================================\n\n//Global variables dictionary\n/*\n  Fields are (name => description):\n\n  NewCycleStarted => Continue current or start new cycle?\n  KillOneCreature => Kill one creature or it has been already killed in current life cycle?\n  NextOrdinalNumber => Ordinal number for next created genotype\n  PerformanceCalculationMethod => Choosen performance calculation method before switching performance calculation off\n  NumberOfCreaturesToShift\n  ShiftedCreatureIndex1\n  ShiftedCreatureIndex2\n  DeletedCreatureIndex\n  DeletedGenotypeIndex\n  CreaturesCircleNormalizedRadius => \"Normalized radius of creatures circle\" from (0, 1] interval\n    Percentage of the \"World radius\".\n    \"Radius of creatures circle\" = \"Normalized radius of creatures circle\" * \"World radius\".\n    \"World radius\" is a segment from world center to world boundary.\n  CreatureShiftNormalizedLength => \"Normalized length of creature shift\" from (0, 1) interval\n    Percentage of the \"Radius of creatures circle\".\n    While creature is shifted towards world center or back it covers the distance equal to \"Normalized length of creature shift\" * \"Radius of creatures circle\".\n  StepsForCreatureShift => Number of steps per creature shift\n    Number of steps each creature does when shifted from creatures circle circumference towards world center or back.\n    Creatures shifting is used to show parent (in case of mutation or copy) or parents (in case of crossover) for current creature,\n    which appears in the center of the circle.\n  StepsForCreatureShiftFinish => Number of steps per creature shift finish\n    Used when creature from the circle center replaces creature from circle circumference.\n    Process of exchange has three phases:\n    1) Creature from the center approaches creature from the circle circumference\n       (\"Number of steps per creature shift\" is used at this time),\n    2) Creature from the circle circumference disapears,\n    3) Moving creature finishes its move and takes place just released at circle circumference\n    \"Number of steps per creature shift finish\" is used to establish in how many steps last (i.e. third) phase happens.\n  NormalizedRadiusIncrementPerShiftStep =>\n    Fraction of the creatures' circle radius added to (subtracted from) currently moving creature radius on each shift step.\n    Shift is always towards circle center from one of the well defined positions on the circle or towards one of the well defined positions on the circle, from circle center.\n    Should be value from range (0,1].\n  NormalizedRadiusIncrementPerShiftFinishStep => Should be value from range (0,1].\n*/\nglobal globals;\n\n//Vector of global variables names (i.e. strings indexing globals dictionary).\n//Unfortunately the Dictionary class doesn't have any method to get entries names so they must be set manually (Update 2013: now it has - Dictionary.getKey(i)).\n//SIC: Update globalsNames initialization section in onExpDefLoad when adding, deleting or changing any global variable name in globals dictionary.\nglobal globalsNames;\n\n//Vector of creatures fields names, containing names of the fields that should be saved into corresponding genotype user3 field by prepareGenotypesForWrite function, when saving experiment state\nglobal savedCreatureFieldsNames;\n\n//================================================================================\n\n@include \"standard_select.inc\"\n@include \"standard_placement.inc\"\n\n//================================================================================\n\n/*\n********************************\n  BEGIN STANDARD FUNCTIONS BLOCK\n********************************\n*/\n\n//================================================================================\n\n//Experiment definition loading\n//*********************\nfunction onExpDefLoad()\n//*********************\n{\n  //Genotypes group\n  GenePools[0].name = \"Genotypes\"; //Group zero is the default one and doesn't have to be added\n\n  //Creatures group\n  var pop=Populations[0];\n  pop.name = \"Creatures\";\n  pop.energy = 0; //No energy calculation\n  pop.death = 0; //No death\n  pop.nnsim = 1; //Immediate neural net simulation\n  pop.enableperf = 1; //Immediate performance calculation\n  pop.perfperiod = 50; //Performance sampling period\n  pop.selfmask = pop.othermask = 0; //Disable colisions\n  \n  //Experiment parameters initialization\n  ExpProperties.initialgen = \"X\"; //Initial genotype, mutated to create initial population of genotypes\n  ExpProperties.delrule = 2; //Delete the worst genotype\n  ExpProperties.MaxCreated = 9; //World capacity\n  ExpProperties.rotation = 4; //Random rotation\n  ExpProperties.creath = 0.1; //Creation height\n  ExpProperties.predefinedSetup = 0; //Choose predefined setup\n  ExpProperties_predefinedSetup_set(); //Load predefined setup\n  ExpProperties.lifeLengthInSteps = 400;\n  ExpProperties.numberOfIdleSteps = 50;\n\n  //Experiment state initialization\n  ExpState.totaltestedcr = 0; //Total number of creatures evaluated so far\n  ExpState.stepType = 0; //Normal simulation\n  ExpState.stepsCounter = 0; //Number of steps in current life cycle\n\n  //Set world parameters\n  World.wrldtyp = 0; //Flat surface\n  World.wrldbnd = 0; //No world boundary\n  World.wrldsiz = 20; //Side length of the world\n\n  //Set vector of global variables names (i.e. strings indexing globals dictionary).\n  //SIC: Update this section when adding, deleting or changing any global variable name in globals dictionary.\n  globalsNames = [\"NewCycleStarted\",\"KillOneCreature\",\"NextOrdinalNumber\",\"PerformanceCalculationMethod\",\"NumberOfCreaturesToShift\",\"ShiftedCreatureIndex1\",\"ShiftedCreatureIndex2\",\"DeletedCreatureIndex\",\"DeletedGenotypeIndex\",\"CreaturesCircleNormalizedRadius\",\"CreatureShiftNormalizedLength\",\"StepsForCreatureShift\",\"StepsForCreatureShiftFinish\",\"NormalizedRadiusIncrementPerShiftStep\",\"NormalizedRadiusIncrementPerShiftFinishStep\"];\n\n  //Set vector of saved creature fields names\n  //SIC: Update this section when you want to change creature's fields saved as a string in genotype's user3 field\n  //SIC: If you update this section remember to update also the appriopriate switch in arrangeCreatures function\n  savedCreatureFieldsNames = [\"perf\",\"nnenabled\",\"lifespan\",\"c_velocity\",\"c_vertpos\",\"user1\",\"user2\",\"user3\"];\n\n  //Create global variables dictionary\n  globals = {\n  //Set changeable global variables\n   \"NewCycleStarted\":0,\n   \"KillOneCreature\":0,\n   \"NextOrdinalNumber\":1,\n  //Set constant global variables\n   \"CreaturesCircleNormalizedRadius\":1,\n   \"CreatureShiftNormalizedLength\":0.6,\n   \"StepsForCreatureShift\":18,\n   \"StepsForCreatureShiftFinish\":12\n             };\n\n  //Calculate constant global variables\n  globals[\"NormalizedRadiusIncrementPerShiftStep\"]=globals[\"CreatureShiftNormalizedLength\"] / globals[\"StepsForCreatureShift\"];\n  globals[\"NormalizedRadiusIncrementPerShiftFinishStep\"]=(1.0 - globals[\"CreatureShiftNormalizedLength\"]) / globals[\"StepsForCreatureShiftFinish\"];\n}\n\n//================================================================================\n\n//Experiment initialization\n//******************\nfunction onExpInit()\n//******************\n{\n  //Clear groups\n  GenePools[0].clear();\n  Populations[0].clear();\n\n  //Reset total number of simulation steps\n  Simulator.stepNumber = 0;\n\n  //Reset total number of evaluated creatures\n  ExpState.totaltestedcr = 0;\n  //Reset step type\n  ExpState.stepType = 0;\n  //Reset steps counter\n  ExpState.stepsCounter = 0;\n\n  //Reset (Set) changeable global variables\n  globals[\"NewCycleStarted\"]=0;\n  globals[\"KillOneCreature\"]=0;\n  globals[\"NextOrdinalNumber\"]=1;\n\n  //Create ExpProperties.MaxCreated genotypes as mutants of ExpProperties.initialgen\n  createInitialGenotypes();\n  //Place all genotypes' corresponding creatures in the world, in the circle\n  arrangeCreatures(\"circle\");\n}\n\n//================================================================================\n\n//New organism created in the world\n//***************\nfunction onBorn(cr)\n//***************\n{\n  //Place new creature in the world's center\n  placeCreatureRandomly(cr, 1, ExpProperties.rotation);\n}\n\n//================================================================================\n\n//Simulation step\n//***************\nfunction onStep()\n//***************\n{\n  var pop=Populations[0];\n\n//  Simulator.print(\"onStep stepType=\"+ExpState.stepType+\" stepsCounter=\"+ExpState.stepsCounter);\n\n  switch (ExpState.stepType)\n  {\n    case 0: //Normal step\n      //New life cycle has to be started\n      if (ExpState.stepsCounter == 0 && globals[\"NewCycleStarted\"] == 0)\n      {\n        //Kill one creature to fullfill creatures limit - choose which one\n        if (globals[\"KillOneCreature\"] == 1)\n        {\n          globals.set(\"KillOneCreature\", 0);\n\n          var creatureIndex;\n          var creaturesCount = pop.size;\n\t  var cr = findCreatureByStatus(\"simulation\");\n\n          //Update genotype for current creature\n          getGenotypeByOrdinalNumber(cr.user2).addPerformanceFromCreature(cr);\n\n          cr.nnenabled = 0; //Switch off simulated creature's neural network\n          cr.perf = 0; //Switch off simulated creature's performance calculation\n\n          //Get index of the genotype to delete\n\t  var pool=GenePools[0];\n          globals.set(\"DeletedGenotypeIndex\", selectedForDeletionInPool(pool).index);\n          //Get ordinal number of the genotype to delete\n          var deletedGenotypeOrdinalNumber = pool[globals[\"DeletedGenotypeIndex\"]].num;\n\n          //Genotype for currently dying creature was selected for deletion\n          if (deletedGenotypeOrdinalNumber == cr.user2)\n          {\n            //Kill really simulated (current) creature\n            pop.kill(cr.index);\n            //Delete the genotype corresponding to deleted creature\n\t    pool.delete(globals[\"DeletedGenotypeIndex\"]);\n\n            ExpState.stepsCounter = 0; //Reset steps counter\n            ExpState.stepType = 11; //Do idle steps\n          }\n          //Other genotype has been selected for deletion\n          else\n          {\n            //Find creature for selected genotype (using genotype's ordinal number and creature's user2 field)\n            globals.set(\"DeletedCreatureIndex\", findCreatureIndexByOrdinalNumber(deletedGenotypeOrdinalNumber));\n\n            var tempVector = Vector.new();\n            //Copy angle from creature to delete to current creature, which will soon take deleted creature's position\n            //and need to know this angle to approach the circle boundary\n            tempVector.add(pop[globals[\"DeletedCreatureIndex\"]].user3[0]);\n            //Set central creature's radius\n            tempVector.add(0.0);\n            cr.user3 = tempVector;\n\n            //Save performance calculation method and switch performance calculation off\n            globals.set(\"PerformanceCalculationMethod\", pop.enableperf);\n            pop.enableperf = 0; //Switch off performance calculation for all creatures\n\n            ExpState.stepType = 7; //Currently simulated creature returns to the middle of the circle\n            ExpState.stepsCounter = 0; //Reset number of steps\n          }\n        }\n        //Create new creature since there is enough place in the world\n        else\n        {\n          //Create new genotype, put it into temporary buffer and select it\n          var g=createGenotype(); //New genotype has information about it's parent (parents)\n\n          if (g.is_valid)\n          {\n            //Set appriopriate ordinal number\n            g.num = globals[\"NextOrdinalNumber\"];\n            //Increment ordinal number for future use\n            globals.set(\"NextOrdinalNumber\", globals[\"NextOrdinalNumber\"] + 1);\n\n\t    g.clone().moveTo(GenePools[0]); //Place genotype in gene pool 0\n            g.instances = 0; //Set instances to zero in order to mark, that this genotype has not been evaluated yet\n\n            globals.set(\"NewCycleStarted\", 1);\n\n            globals.set(\"PerformanceCalculationMethod\", pop.enableperf); //Save performance calculation method\n            pop.enableperf = 0; //Switch off performance calculation for all creatures\n\n            ExpState.stepType = 1; //Parent (Parents) approaching to the center of the circle\n            ExpState.stepsCounter = 0; //Reset number of steps\n          }\n          else\n            Simulator.message(\"invalid genotype - ignored: \" + g.info, 1);\n        }\n      }\n      else\n      {\n        ExpState.stepsCounter++;\n\n        if (ExpState.stepsCounter >= ExpProperties.lifeLengthInSteps) //Simulated creature life cycle has ended\n        {\n          ExpState.stepsCounter = 0;\n          globals.set(\"NewCycleStarted\", 0);\n          globals.set(\"KillOneCreature\", 1);\n        }\n      }\n      break;\n\n    case 1: //Parent (Parents) approaching to the center of the circle\n      if (ExpState.stepsCounter == 0) //It's first time when current case is beeing executed - mark creature (creatures) to move and do the first move\n      {\n        var pool=GenePools[0];\n        var g=pool[pool.size-1]; //most recenly added\n\n//\tSimulator.print(\"pool.size=\"+pool.size+\" g=\"+g+\" g.user1=\"+g.user1+\" g.user2=\"+g.user2+\" g.user3=\"+g.user3);\n\n        //Get parent (parents) for current genotype\n        if (g.user1 == \"copy\" || g.user1 == \"mutant\" || (g.user1 == \"cross\" && g.user2 == g.user3) || g.user1 == \"copy - second genotype for crossover not found\")\n        {\n          globals.set(\"NumberOfCreaturesToShift\", 1);\n          globals.set(\"ShiftedCreatureIndex1\", findCreatureIndexByOrdinalNumber(g.user2));\n        }\n        else if (g.user1 == \"cross\" && g.user2 != g.user3)\n        {\n          globals.set(\"NumberOfCreaturesToShift\", 2);\n          globals.set(\"ShiftedCreatureIndex1\", findCreatureIndexByOrdinalNumber(g.user2));\n          globals.set(\"ShiftedCreatureIndex2\", findCreatureIndexByOrdinalNumber(g.user3));\n        }\n\n        doShiftStep(\"inside\", globals[\"NormalizedRadiusIncrementPerShiftStep\"]);\n        ExpState.stepsCounter++;\n      }\n      else if (ExpState.stepsCounter >= globals[\"StepsForCreatureShift\"]) //All shift steps done\n      {\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 2; //Go to next stage\n      }\n      else //Next shift step\n      {\n        doShiftStep(\"inside\", globals[\"NormalizedRadiusIncrementPerShiftStep\"]);\n        ExpState.stepsCounter++;\n      }\n      break;\n\n    case 2: //Idle steps before creating new creature\n      if (ExpState.stepsCounter >= ExpProperties.numberOfIdleSteps) //All idle steps done\n      {\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 3; //Go to next stage\n      }\n      else //Next idle step\n        ExpState.stepsCounter++;\n      break;\n\t\n    case 3: //Parent (Parents) ready - create new creature in the world\n      {\n      //Bring creature to life\n      var pool=GenePools[0];\n      var g=pool[pool.size-1]; //most recenly added\n      var cr=pop.add(g); //Implicit onBorn call\n\n      cr.user1 = \"simulation\"; //Remember that this creature is the really simulated one\n      cr.user2 = g.num; //Remember which genotype results in current creature\n      cr.user3 = [-1, 0.0];\n\n      cr.nnenabled = 0; //Disable neural network for current creature\n      cr.perf = 0; //And switch off its performance calculation\n\n      ExpState.stepType = 4; //Go to next stage\n      }\n      break;\n\n    case 4: //Idle steps after creating new creature\n      if (ExpState.stepsCounter >= ExpProperties.numberOfIdleSteps) //All idle steps done\n      {\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 5; //Go to next stage\n      }\n      else //Next idle step\n        ExpState.stepsCounter++;\n      break;\n\n    case 5: //Parent (Parents) returning to original place (places)\n      if (ExpState.stepsCounter >= globals[\"StepsForCreatureShift\"]) //All shift steps done\n      {\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 6; //Go to next stage\n      }\n      else //Next shift step\n      {\n        doShiftStep(\"outside\", globals[\"NormalizedRadiusIncrementPerShiftStep\"]);\n        ExpState.stepsCounter++;\n      }\n      break;\n\n    case 6: //Parents on their original places - start simulation\n      var creatureIndex;\n      var creaturesCount = pop.size;\n      var cr = findCreatureByStatus(\"simulation\");\n\n      cr.nnenabled = 1; //Enable neural network for current creature\n      cr.perf = 1; //And switch on its performance calculation\n\n      pop.enableperf = globals[\"PerformanceCalculationMethod\"]; //Restore performance calculation method\n\n      ExpState.stepsCounter = 0; //Reset steps counter\n      ExpState.stepType = 0; //Go to stage 0\n      break;\n\n    case 7: //Currently simulated creature returns to the middle of the circle (if it has moved from it)\n      //TODO - move simulated creature smoothly (or instantly) to the circle center\n\n      ExpState.stepsCounter = 0; //Reset steps counter\n      ExpState.stepType = 8; //Go to next stage\n      break;\n\n    case 8: //Creature from the middle approaches circle boundary\n      if (ExpState.stepsCounter == 0) //It's first time when current case is beeing executed - mark creature to move and do the first move\n      {\n        globals.set(\"NumberOfCreaturesToShift\", 1);\n        globals.set(\"ShiftedCreatureIndex1\", findCreatureByStatus(\"simulation\").index); //Mark currently dying creature (from the middle of the circle)\n\n        doShiftStep(\"outside\", globals[\"NormalizedRadiusIncrementPerShiftStep\"]);\n        ExpState.stepsCounter++;\n      }\n      else if (ExpState.stepsCounter >= globals[\"StepsForCreatureShift\"]) //All shift steps done\n      {\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 9; //Go to next stage\n      }\n      else //Next shift step\n      {\n        doShiftStep(\"outside\", globals[\"NormalizedRadiusIncrementPerShiftStep\"]);\n        ExpState.stepsCounter++;\n      }\n      break;\n\n    case 9: //Delete creature from the circle boundary; delete its genotype from GenePools\n      {\n      //Select creature to kill and remove it from the world\n      pop.kill(globals[\"DeletedCreatureIndex\"]);\n\n      //Select genotype to delete (corresponding to killed creature) and delete it from gene pool\n      GenePools[0].delete(globals[\"DeletedGenotypeIndex\"]);\n\n      //Deleting a creature affects indices within Populations => update of global variable \"ShiftedCreatureIndex1\" needed\n      var creatureIndex;\n      var creaturesCount = pop.size;\n\n      //Search for moving creature and select it once more\n      for (creatureIndex = 0; creatureIndex < creaturesCount; creatureIndex++)\n      {\n        if (pop[creatureIndex].user1 == \"simulation\") //Really simulated creature found\n           {\n           globals.set(\"ShiftedCreatureIndex1\", creatureIndex); //Update global variable \"ShiftedCreatureIndex1\"\n\n           break;\n           }\n      }\n\n      ExpState.stepsCounter = 0; //Reset steps counter\n      ExpState.stepType = 10; //Go to next stage\n      }\n      break;\n\n    case 10: //Creature from the middle finishes its move to the circle boundary\n      if (ExpState.stepsCounter >= globals[\"StepsForCreatureShiftFinish\"]) //All shift finish steps done\n      {\n        pop[globals[\"ShiftedCreatureIndex1\"]].user1 = \"visualization\"; //Mark creature as visualization\n\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 11; //Go to next stage\n      }\n      else //Next shift finish step\n      {\n        doShiftStep(\"outside\", globals[\"NormalizedRadiusIncrementPerShiftFinishStep\"]);\n        ExpState.stepsCounter++;\n      }\n      break;\n\n    case 11: //Idle steps after circle circumference creature replacement or after central creature disappearance\n      if (ExpState.stepsCounter >= ExpProperties.numberOfIdleSteps) //All idle steps done\n      {\n        ExpState.stepsCounter = 0; //Reset steps counter\n        ExpState.stepType = 0; //Go to stage 0\n        pop.enableperf = globals[\"PerformanceCalculationMethod\"]; //Restore performance calculation method\n      }\n      else //Next idle step\n        ExpState.stepsCounter++;\n      break;\n  }\n}\n\n//================================================================================\n\n//Function called to kill currently selected creature\n//***************\nfunction onDied()\n//***************\n{\n  ExpState.totaltestedcr++;\n  Simulator.checkpoint();\n}\n\n//================================================================================\n\n/*\n******************************\n  END STANDARD FUNCTIONS BLOCK\n******************************\n*/\n\n//================================================================================\n\n//*******************************\nfunction createInitialGenotypes()\n//*******************************\n{\n  var i;\n  //Spawn genotype library with mutations of initial genotype\n  for (i = 0; i < ExpProperties.MaxCreated - 1; i++)\n  {\n    var g=Genotype.newFromGeno(GenMan.mutate(Geno.newFromString(ExpProperties.initialgen)));//Create new genotype, mutate it\n    g.instances = 0; //Set number of instances to 0 (genotypes not evaluated yet)\n    //g.instances = 1; //Set number of instances to 1\n\n    //Set all user fields\n    g.user1 = \"initial\";\n    g.user2 = null;\n    g.user3 = null;\n\n    //Set appriopriate ordinal number\n    g.num = globals[\"NextOrdinalNumber\"];\n    //Increment ordinal number for future use\n    globals.set(\"NextOrdinalNumber\", globals[\"NextOrdinalNumber\"] + 1);\n\n    //Place genotype from buffer in gene pool 0 and make it current\n    g.moveTo(GenePools[0]);\n  }\n}\n\n//================================================================================\n\n//Function used to create creatures from genotypes.\n//When placing creatures one have to remember that each creature is enclosed in a box with one stick length margin.\n//Creature.locationSetBboxLow method moves bottom-left-down corner of the creature to the given 3D point\n//Therefore if for example we want to have creature's center at [20.0, 10.0, z] coordinates,\n//and our creature genotype is X (one stick along OX axis),\n//we have to move the creature to absolute location [18.5, 9.0],\n//since it's bboxSize.x is 3.0 and its bboxSize.y is 2.0 and:\n//18.5 = 20.0 - 3.0 / 2\n//9.0  = 10.0 - 2.0 / 2\n//****************************\nfunction arrangeCreatures(how)\n//****************************\n{\n  var centerCoordinates; //x and y\n  var lowerLeftCornerCoordinates; //x and y\n\n  var pool=GenePools[0];\n  var pop=Populations[0];\n  var genotypesCount = pool.size; //Get number of genotypes to visualize\n  var genotypeIndex;\n\n  //Place all creatures in the world\n  for (genotypeIndex = 0; genotypeIndex < genotypesCount; genotypeIndex++)\n  {\n    //Select next genotype from gene pool 0\n    var g=pool[genotypeIndex];\n    var cr;\n\n    //Place all initial genotype's corresponding creatures in the circle\n    if (how == \"circle\")\n    {\n      //Bring creature to life\n    cr=pop.add(g); //Implicit onBorn call\n\n      cr.user1 = \"visualization\"; //Remember that this creature only represents some genotype from gene pool\n      cr.user2 = g.num; //Remember which genotype results in current creature\n      cr.user3 = [(Math.twopi * genotypeIndex) / genotypesCount, 1.0];\n  \n      cr.nnenabled = 0; //Switch off neural net for current creature\n      cr.perf = 0; //And switch off its performance calculation\n    }\n    //Create creatures on the basis of their details from genotypes' user3 fields (if genotype's user3 field is not empty)\n    else if (how == \"restore\")\n    {\n      //No corresponding creature yet => go to next genotype\n      if ((g.user3 == \"null\") || (g.user3 == null))\n        continue;\n\n      //Bring creature to life\n      cr=pop.add(g); //Implicit onBorn call\n\n      if (typeof(g.user3)==\"Dictionary\")\n          { // new style: user3 field was automatically deserialized, keys and values are directly accessible\n\t  for (var i=0;i<g.user3.size;i++)\n\t      cr.[g.user3.getKey(i)]=g.user3[i];\n          }\n      else\n          { // old style: user3 contains a hand crafted string \"name=value&name=value&...\"\n      var fieldsVector = String.split(g.user3, \"&\");\n\n      var fieldIndex;\n      var fieldVector;\n      var fieldName;\n      var fieldValue;\n      var fieldValueVector;\n      var fieldValueVectorIndex;\n\n      for (fieldIndex = 0; fieldIndex < fieldsVector.size; fieldIndex++)\n      {\n        fieldVector = String.split(fieldsVector[fieldIndex], \"=\");\n        fieldName = fieldVector[0];\n        fieldValue = fieldVector[1];\n\n        //Value represents a vector\n        if (String.indexOf(fieldValue, \"|\") >= 0)\n        {\n          fieldValueVector = String.split(fieldValue, \"|\");\n          for (fieldValueVectorIndex = 0; fieldValueVectorIndex < fieldValueVector.size; fieldValueVectorIndex++)\n            //Replace string with parsed value\n            fieldValueVector.set(fieldValueVectorIndex, parseValue(fieldValueVector[fieldValueVectorIndex]));\n\n          //Only user1, user2, and user3 fields may contain vectors, since none of standard Creature fields is of type Vector\n          switch (fieldName)\n          {\n            case \"user1\":\n              cr.user1 = fieldValueVector;\n\t      break;\n            case \"user2\":\n              cr.user2 = fieldValueVector;\n\t      break;\n            case \"user3\":\n              cr.user3 = fieldValueVector;\n\t      break;\n          }\n        }\n        //Simple value\n        else\n          //Update this switch if you changed savedCreatureFieldsNames variable\n          switch (fieldName)\n          {\n            case \"perf\":\n              cr.perf = parseValue(fieldValue);\n\t      break;\n            case \"nnenabled\":\n              cr.nnenabled = parseValue(fieldValue);\n\t      break;\n            case \"lifespan\":\n              cr.lifespan = parseValue(fieldValue);\n\t      break;\n            case \"c_velocity\":\n              cr.c_velocity = parseValue(fieldValue);\n\t      break;\n            case \"c_vertpos\":\n              cr.c_vertpos = parseValue(fieldValue);\n\t      break;\n            case \"user1\":\n              cr.user1 = parseValue(fieldValue);\n\t      break;\n            case \"user2\":\n              cr.user2 = parseValue(fieldValue);\n\t      break;\n          }\n      } //for fieldIndex\n          } //old style\n    }//if how==restore\n\n    //Calculate creature's coordinates\n    centerCoordinates = getXYForPoleCoordinates(cr.user3); //Coordinates of creature's center\n    lowerLeftCornerCoordinates = getXYForCreatureLowerLeftCorner(centerCoordinates[0], centerCoordinates[1], cr.bboxSize.x, cr.bboxSize.y); //Coordinates of creature's lower left corner\n\n    //Move current creature\n    //TODO - eventually change creature z coordinate after move, if world is higher in target place\n    cr.locationSetBboxLow(lowerLeftCornerCoordinates[0], lowerLeftCornerCoordinates[1], cr.bboxLow.z);//Assigning values for creature's pos_x, pos_y or center_x, center_y doesn't work\n  }\n\n}\n\n//================================================================================\n\n//Function translating coordinates from pole (center = world center; radius fraction in [0, 1], equal to poleCoordinates[1]; angle in [0, 2*pi], equal to poleCoordinates[0]) to cartesian\n//When radius fraction == 1, then radius equals to creatures' circle radius\n//Creatures' circle radius == (World.wrldsiz / 2) * globals[\"CreaturesCircleNormalizedRadius\"]\n//***********************************************\nfunction getXYForPoleCoordinates(poleCoordinates)\n//***********************************************\n{\n  var coordinates = []; //Create new vector\n\n  //Calculate coordinates for the center of the world\n  var centerX = World.wrldsiz / 2;\n  var centerY = World.wrldsiz / 2;\n\n  //Calculate non-normalized radius\n  var radius = (World.wrldsiz / 2) * globals[\"CreaturesCircleNormalizedRadius\"] * poleCoordinates[1];\n\n  //Calculate creature's coordinates\n  coordinates.add(centerX + Math.cos(poleCoordinates[0]) * radius);\n  coordinates.add(centerY + Math.sin(poleCoordinates[0]) * radius);\n  \n  return coordinates;\n}\n\n//================================================================================\n\n//Get lower left corner 2D coordinates for a creature whose center must be at [centerX, centerY] and whose 2D size is sizeX * sizeY\n//**********************************************************************\nfunction getXYForCreatureLowerLeftCorner(centerX, centerY, sizeX, sizeY)\n//**********************************************************************\n{\n  var coordinates = Vector.new(); //Create new vector\n\n  coordinates.add(centerX - sizeX / 2);\n  coordinates.add(centerY - sizeY / 2);\n\n  return coordinates;\n}\n\n//================================================================================\n\n//Function used to get genotype index in GenePools class, for genotype with given ordinal number\n//******************************************************\nfunction getGenotypeByOrdinalNumber(ordinalNumber)\n//******************************************************\n{\n  var genotypeIndex;\n\n//  Simulator.print(\"findGe \"+ordinalNumber);\n\n  var pool=GenePools[0];\n  for (genotypeIndex = 0; genotypeIndex < pool.size; genotypeIndex++)\n  {\n    var genotype = pool[genotypeIndex];\n//    Simulator.print(\" \"+genotypeIndex+\". \"+genotype.num);\n    if (genotype.num == ordinalNumber)\n    {\n      return genotype;\n    }\n  }\n\n  return null;\n}\n\n//================================================================================\n\n//Function used to get creature index in Populations class, representing genotype with given ordinal number\n//******************************************************\nfunction findCreatureIndexByOrdinalNumber(ordinalNumber)\n//******************************************************\n{\n  var result = -1;\n  var creatureIndex;\n\n//  Simulator.print(\"findCr \"+ordinalNumber);\n\n  for (creatureIndex = 0; creatureIndex < Populations.get(0).size; creatureIndex++)\n  {\n    var creature = Populations.get(0).get(creatureIndex);\n//    Simulator.print(\" \"+creatureIndex+\". \"+creature.user2);\n    if (creature.user2 == ordinalNumber)\n    {\n      result = creatureIndex;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction findCreatureByStatus(status) // status == user1 (initial, simulation, mutant, copy, cross)\n{\nvar pop=Populations[0];\nvar i;\nfor(i=0;i<pop.size;i++)\n\t{\n\tvar cr=pop[i];\n\tif (cr.user1==status) return cr;\n\t}\nreturn null;\n}\n\n//================================================================================\n\n//Function used to perform one shift step using absolute creature positioning\n//It uses these global variables:\n//- globals\n//***************************************************************\nfunction doShiftStep(shiftType, normalizedRadiusIncrementPerStep)\n//***************************************************************\n{\n  var centerCoordinates;\n  var lowerLeftCornerCoordinates;\n\n  var pop=Populations[0];\n  var cr = pop[globals[\"ShiftedCreatureIndex1\"]]; //Select parent 1 creature\n\n//  Simulator.print(\"doshift \"+globals[\"ShiftedCreatureIndex1\"]+\" stepType=\"+ExpState.stepType);\n\n  //Move parent 1 along its radius, in right direction\n  switch (shiftType)\n  {\n    case \"inside\":\n      cr.user3.set(1, cr.user3[1] - normalizedRadiusIncrementPerStep);\n      centerCoordinates = getXYForPoleCoordinates(cr.user3);\n      break;\n\n    case \"outside\":\n      cr.user3.set(1, cr.user3[1] + normalizedRadiusIncrementPerStep);\n      centerCoordinates = getXYForPoleCoordinates(cr.user3);\n      break;\n  }\n  lowerLeftCornerCoordinates = getXYForCreatureLowerLeftCorner(centerCoordinates[0], centerCoordinates[1], cr.bboxSize.x, cr.bboxSize.y); //Coordinates of creature's lower left corner\n  //TODO - eventually change creature z coordinate after move, if world is higher in target place\n  cr.locationSetBboxLow(lowerLeftCornerCoordinates[0], lowerLeftCornerCoordinates[1], cr.bboxLow.z);\n\n  //Move parent 2 along its radius, in right direction (if present)\n  if (globals[\"NumberOfCreaturesToShift\"] == 2)\n  {\n    cr = pop[globals[\"ShiftedCreatureIndex2\"]]; //Select parent 2 creature\n\n    //Move parent 2 in right direction\n    switch (shiftType)\n    {\n      case \"inside\":\n        cr.user3.set(1, cr.user3[1] - normalizedRadiusIncrementPerStep);\n        centerCoordinates = getXYForPoleCoordinates(cr.user3);\n        break;\n\n      case \"outside\":\n        cr.user3.set(1, cr.user3[1] + normalizedRadiusIncrementPerStep);\n        centerCoordinates = getXYForPoleCoordinates(cr.user3);\n        break;\n    }\n    lowerLeftCornerCoordinates = getXYForCreatureLowerLeftCorner(centerCoordinates[0], centerCoordinates[1], cr.bboxSize.x, cr.bboxSize.y); //Coordinates of creature's lower left corner\n    //TODO - eventually change creature z coordinate after move, if world is higher in target place\n    cr.locationSetBboxLow(lowerLeftCornerCoordinates[0], lowerLeftCornerCoordinates[1], cr.bboxLow.z);\n  }\n}\n\n//================================================================================\n\n//Creates new genotype and returns it\n//********************************\nfunction createGenotype()\n//********************************\n{\n  var parentGenotypeOrdinalNumber1;\n  var parentGenotypeOrdinalNumber2;\n  var pool=GenePools[0];\n  var g;\n\n  var sel;\n  sel = (ExpProperties.p_nop + ExpProperties.p_mut + ExpProperties.p_xov) * Math.rnd01;\n  if (sel < ExpProperties.p_nop)\n  {\n    g = selectedForCreationInPool(pool);\n    parentGenotypeOrdinalNumber1 = g.num; //Save current genotype's (parent's) ordinal number\n\n    g=Genotype.newFromGeno(g.geno); //Copy current genotype\n\n    //Remember parent\n    g.user1 = \"copy\";\n    g.user2 = parentGenotypeOrdinalNumber1;\n    g.user3 = null;\n  }\n  else\n  {\n    sel = sel - ExpProperties.p_nop;\n    if (sel < ExpProperties.p_mut)\n    {\n      g = selectedForCreationInPool(pool); //Select current genotype\n      parentGenotypeOrdinalNumber1 = g.num; //Save current genotype's (parent's) ordinal number\n\n      g=Genotype.newFromGeno(GenMan.mutate(g.geno)); //Mutate current genotype\n\n      //Remember parent\n      g.user1 = \"mutant\";\n      g.user2 = parentGenotypeOrdinalNumber1;\n      g.user3 = null;\n    }\n    else\n    {\n      var other;\n\n      g = selectedForCreationInPool(pool); //Select current genotype\n      parentGenotypeOrdinalNumber1 = g.num; //Save parent 1 ordinal number\n\n      if (ExpProperties.xov_mins > 0.0)\n        other = selectedSimilarInPool(pool,g);\n      else\n        other = selectedForCreationInPool(pool);\n\n      if (other)\n      {\n        parentGenotypeOrdinalNumber2 = other.num; //Save parent 2 ordinal number\n        g=Genotype.newFromGeno(GenMan.crossOver(g.geno,other.geno)); //Crossover current and other genotype\n\n        //Remember parents\n        g.user1 = \"cross\";\n        g.user2 = parentGenotypeOrdinalNumber1;\n        g.user3 = parentGenotypeOrdinalNumber2;\n      }\n      else\n      {\n        g=Genotype.newFromGeno(g.geno); //Copy current genotype\n\n        //Remember parent\n        g.user1 = \"copy - second genotype for crossover not found\";\n        g.user2 = parentGenotypeOrdinalNumber1;\n        g.user3 = null;\n\n        Simulator.print(\"crossover - second genotype not found?\");\n      }\n    }\n  }\n\n  return g;\n}\n\n\n//Change predefined setup\n//**************************************\nfunction ExpProperties_predefinedSetup_set()\n//**************************************\n{\n\tvar pop=Populations[0];\n\t//Note: pop.enableperf=2 below would not be really meaningful because performance is turned on/off manually - see the big switch(...) in onStep().\n\t//This could be changed, but we originally assumed that in this experiment, the number of steps a creature spends on evaluation should be constant.\n\t//So in the lack of stabilization period, the \"max velocity\" criterion suffers from initial, random, unintentional movements :/ \n  switch (ExpProperties.predefinedSetup)\n  {\n    case 0: //Vertical position optimization\n      Simulator.import(\"show_evol_vertpos.sim\"); //a smart fitness function in script (better fitness landscape)\n      pop.nnsim = 0; //off\n      pop.enableperf = 1; //immediate\n      break;\n      \n    case 1: //Velocity optimization\n      GenePools[0].fitness=\"return this.velocity;\";\n      pop.nnsim = 1; //should be 2 (after stabilization) but see the note above (also remember that nnsim should cooperate with enableperf)\n      pop.enableperf = 1; //should be 2 (after stabilization) but see the note above\n      break;\n      \n    case 2: //Body size optimization\n      GenePools[0].fitness=\"return this.numparts;\";\n      pop.nnsim = 0; //off\n      pop.enableperf = 1; //immediate\n      break;\n  }\n  setMutationProbabilities(pop.nnsim);\n}\n\n//this function adjusts key probabilities so that irrelevant mutations (for selected fitness) are not performed\nfunction setMutationProbabilities(mutate_brain)\n{\n  if (mutate_brain==0)\n  {\n    GenMan.f0_n_new=GenMan.f0_n_del=GenMan.f0_c_new=GenMan.f0_c_del=0;\n    GenMan.f0_n_prp=GenMan.f0_c_wei=0;\n    GenMan.f1_nmConn=0;\n    GenMan.f1_nmNeu=0;\n    GenMan.f1_nmProp=0;\n    GenMan.f1_nmVal=0;\n    GenMan.f1_nmWei=0;\n  } else //set default probabilities\n  {\n    GenMan.f0_n_new=GenMan.f0_n_del=GenMan.f0_c_new=GenMan.f0_c_del=5;\n    GenMan.f0_n_prp=GenMan.f0_c_wei=10;\n    GenMan.f1_nmConn=0.1;\n    GenMan.f1_nmNeu=0.05;\n    GenMan.f1_nmProp=0.1;\n    GenMan.f1_nmVal=0.05;\n    GenMan.f1_nmWei=1.0;\n  }\n}\n\n\n//================================================================================\n\n//Function used to convert global variables dictionary into a string of \"|\" and \"=\" separated substrings.\n//Each substring is either global variable name or global variable value.\n//Substrings are grouped in pairs, e.g. \"name1=value1|name2=value2\".\n//Created string is saved into ExpState.globals field (original dictionary can't be saved there because Dictionary is not a simple type but a class).\n//Function uses these global variables:\n//- globals\n//- globalsNames\n//******************************\nfunction saveGlobalsToExpState()\n//******************************\n{\n  // previously the only way to save a dictionary was to build its string representation\n  // now it is easy - the built-in serialization will take care of storing and retrieving objects\n  ExpState.globals = globals;\n}\n\n//================================================================================\n\n//Get string of global variables names and values pairs from ExpState.globals field, parse it and save globals variables in a dictionary\n//Function uses these global variables:\n//- globals\n//********************************\nfunction loadGlobalsFromExpState()\n//********************************\n{\n  if (typeof(ExpState.globals) == \"Dictionary\")\n     globals=ExpState.globals; //new method: use the built-in serialization\n  else\n      {  //old method: parse the string and re-create the dictionary\n  var globalsString = ExpState.globals;\n\n  //Create vector of name=value substrings\n  var globalsPairs = String.split(globalsString, \"|\");\n  var tempVector;\n\n  //Recreate global variables dictionary\n  globals = Dictionary.new();\n\n  var pairIndex;\n  for (pairIndex = 0; pairIndex < globalsPairs.size; pairIndex++)\n  {\n    //Separate name and value\n    tempVector = String.split(globalsPairs[pairIndex], \"=\");\n\n    //Add global variable to dictionary\n    globals.set(tempVector[0], parseValue(tempVector[1]));\n  }\n     }\n}\n\n//================================================================================\n\n//Parse given string and return null, float, int or string value\n//******************************\nfunction parseValue(valueString)\n//******************************\n{\n  if (valueString==\"null\") return null;\n\n  var num=String.parseNumber(valueString);\n  if (num != null) // integer or float\n     return num;\n\n  return valueString;\n}\n\n//================================================================================\n\n// we need user3 field for saving additional data (creature details), so we compress user2 and user3 into a single field user2 (as an array)\n//Save corresponding creatures details in genotypes' user3 fields (as \"&\" and \"=\" separated strings).\n//*********************************\nfunction prepareGenotypesForWrite()\n//*********************************\n{\n  //Get number of genotypes\n  var pool=GenePools[0];\n  var correspondingCreatureIndex;\n  var creatureDetails;\n\n  //Modify all genotypes\n  for (var g in pool)\n  {\n    g.user2=[g.user2,g.user3];\n\n    //Find corresponding creature\n    correspondingCreatureIndex = findCreatureIndexByOrdinalNumber(g.num);\n\n    //Corresponding creature found\n    if (correspondingCreatureIndex >= 0)\n    {\n      //Corresponding creature's details dictionary\n      creatureDetails = {};\n\n      var cr=Populations[0][correspondingCreatureIndex];\n  \n      for (var fieldName in savedCreatureFieldsNames)\n        creatureDetails[fieldName] = cr.[fieldName];\n\n      //Save corresponding creature's details to current genotype's user3 field\n      g.user3 = creatureDetails;\n    }\n    //Corresponding creature not found\n    else\n      g.user3 = null;\n  }\n}\n\n//================================================================================\n\n//Restore parent genotype ordinal numbers user2 and user3 (compressed to a single field user2 by prepareGenotypesForWrite())\n//****************************\nfunction decompressGenotypes()\n//****************************\n{\n  //Vector of current genotype's parents ordinal numbers\n  var parentsOrdinalNumbers;\n\n  //Modify all genotypes\n  for (var g in GenePools[0])\n  {\n    if (typeof(g.user2)==\"Vector\")\n       { // new style: vector [num1,num2]\n       g.user3=g.user2[1];\n       g.user2=g.user2[0];\n       }\n    else\n       { //old style: string \"parent=num1|num2\"\n       //Split string of \"|\" separated parents ordinal numbers\n       parentsOrdinalNumbers = String.split(String.split(g.user2, \"=\")[1], \"|\");\n       //Save current genotype parent's ordinal numbers in user2 and user3 fields\n       g.user2 = parseValue(parentsOrdinalNumbers[0]);\n       g.user3 = parseValue(parentsOrdinalNumbers[1]);\n       }\n  }\n}\n\n//================================================================================\n\n/*\n********************************\n  BEGIN STANDARD FUNCTIONS BLOCK\n********************************\n*/\n\n//================================================================================\n\n//Experiment state loading\n//******************\nfunction onExpLoad()\n//******************\n{\n  //Global variables were defined and onExpDefLoad was called automatically before this function started executing\n\n  GenePools[0].clear();\n  Populations[0].clear();\n  Loader.addClass(sim_params.*);\n  Loader.addClass(Population.*);\n  Loader.addClass(GenePool.*);\n//  Loader.setBreakLabel(Loader.OnComment, \"onExpLoad_Comment\");\n  Loader.setBreakLabel(Loader.BeforeObject, \"onExpLoad_Object\");\n  Loader.setBreakLabel(Loader.BeforeUnknown, \"onExpLoad_Unknown\");\n  Loader.run();\n  if (GenePools[0].size > 0)\n    Simulator.print(\"Experiment successfully loaded (\" + GenePools[0].size + \" genotypes)\");\n\n  //Load global variables names and values pairs from ExpState.globals field\n  loadGlobalsFromExpState();\n  //Reset globals string\n  ExpState.globals = \"\";\n  //Reset indices values\n  //Create creatures on the basis of their details from genotypes' user3 fields (if genotype's user3 field is not empty)\n  arrangeCreatures(\"restore\");\n  //Restore all genotypes user2 and user3 fields on the basis of the string from user2 field (set separate parents' ordinal numbers in genotypes' user2 and user3 fields)\n  decompressGenotypes();\n}\n\n//================================================================================\n\n//**************************\nfunction onExpLoad_Unknown()\n//**************************\n{\n  if (Loader.objectName != \"org\")\n    return ;\n\n  Loader.currentObject = Genotype.newFromString(\"\");\n  Interface.makeFrom(Loader.currentObject).setAllDefault();\n  Loader.loadObject();\n  Loader.currentObject.clone().moveTo(GenePools[0]);\n}\n\n//================================================================================\n\n//*************************\nfunction onExpLoad_Object()\n//*************************\n{\nswitch(Loader.objectName)\n\t{\n\tcase \"Population\": Loader.currentObject = Populations[0]; break;\n\tcase \"GenePool\": Loader.currentObject = GenePools[0]; break;\n\t}\n}\n\n//================================================================================\n\n//Experiment state saving\n//******************\nfunction onExpSave()\n//******************\n{\n  //Save global variables names and values pairs string into ExpState.globals field\n  saveGlobalsToExpState();\n  //Compress all genotypes (user2, user3) fields pairs into strings and save these strings into user2 field\n  //Save corresponding creatures details in genotypes' user3 fields (as \"&\" and \"=\" separated strings)\n  //(initial creatures' rotations are not saved since they are unimportant)\n  prepareGenotypesForWrite();\n\n  File.writeComment(\"'evolution_demo.expdef' data\");\n  File.writeObject(sim_params.*);\n  File.writeObject(GenePools[0]);\n  File.writeObject(Populations[0]);\n\n  var pool=GenePools[0];\n  var i = 0;  \n  while (i < pool.size)\n  {\n    File.writeNameObject(\"org\", pool[i]);\n    i++;\n  }\n\n  Simulator.print(\"Experiment successfully saved (\" + pool.size + \" genotypes)\");\n\n  //Reset globals string\n  ExpState.globals = \"\";\n  //Reset indices values\n  //Restore all genotypes user2 and user3 fields on the basis of the string from user2 field (set separate parents' ordinal numbers in genotypes' user2 and user3 fields)\n  decompressGenotypes();\n}\n\n//================================================================================\n\n/*\n******************************\n  END STANDARD FUNCTIONS BLOCK\n******************************\n*/\n\n//================================================================================\n\n",
    "info": "This experiment definition demonstrates the process of evolution.\nIndividuals are placed in a circle. A new individual is cloned, mutated, or crossed over. \nThen it is evaluated in the middle of the circle, and - depending on its fitness - may replace a poorer, existing individual, or disappear.",
    "_classname": "expdef",
    "name": "Demonstration of evolution"
  }
]