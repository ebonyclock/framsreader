[
  {
    "name": "Standard",
    "_classname": "style",
    "info": "Default Framsticks visual style",
    "code": "\n@include \"stdneurons.inc\"\n@include \"simplefont.inc\"\n@include \"plane3d.inc\" //for createPlaneVertices()\n\nfunction default_model_build()\n{\nElement.useCreature();\nif (Creature.numjoints>0)\n\tVisualModel.jointshadow = 0.01*VisProperties.joint_width*VisProperties.shadows;\nelse\n\tVisualModel.partshadow = 0.2*VisProperties.shadows;\n\nif (Creature.population)\n{ //in world\nif (VisProperties.shownames)\n  {\n  GeomBuilder.addTransform(VisualModel.rootNode);\n  VertexBuilder.newLines();\n  var t=makeVectorText(Creature.name,0.0,0.0,5.0,0.2,0.4,0.06);\n  VertexBuilder.addVertex([0,0,1,0,0,4.5,-1,0,2,0,0,1,0,0,1,1,0,2]);\n  VertexBuilder.addVertex(t);\n  VertexBuilder.addColor(0xff0000ff);\n  Material.new();\n  Material.setFlat();\n  Material.colormat = GL.AMBIENT_AND_DIFFUSE;\n  Material.disable(GL.TEXTURE_2D);\n  Material.disable(GL.LIGHTING);\n  VertexBuilder.material = Material.object;\n  GeomBuilder.add(VertexBuilder.node);\n  }\n}\nelse\n  { //in body view\n  if (VisProperties.symmetryplane==0) return;\n  \n  VertexBuilder.newQuads();\n  var minx=Creature.pos_x;\n  var miny=Creature.pos_y;\n  var minz=Creature.pos_z;\n  var maxx=minx+Creature.size_x;\n  var maxy=miny+Creature.size_y;\n  var maxz=minz+Creature.size_z;\n\n  //we use a quick, inaccurate mode to just guess the symmetry plane\n  //save original parameters\n  var olda=ModelSymmetry.symAlphaSteps;\n  var oldb=ModelSymmetry.symBetaSteps;\n  var oldp=ModelSymmetry.symPosSteps;\n  \n  //time complexity of ModelSymmetry.calculateSymmetry() is O(alphaSteps*betaSteps*posSteps * sticks^2*log(sticks))\n  var sticks=Creature.model.numjoints;\n  \n  /* set low-quality parameters to quickly guess symmetry plane\n  1. stepsAlpha = stepsBeta\n  2. stepsAlpha >= 2\n  3. posSteps >= 2\n  angles are probably more important than posSteps, but hard to say how much (2, 3 times?) \n  so let's divide angles by sqrt(sticks), and pos by sticks. log(sticks) in time complexity stays not depreciated */\n  ModelSymmetry.symAlphaSteps=Math.max(2.0,20.0/Math.sqrt(sticks));\n  ModelSymmetry.symBetaSteps=ModelSymmetry.symAlphaSteps;\n  ModelSymmetry.symPosSteps=Math.max(2,10/sticks);\n  \n  //calculate\n  var symmetry=ModelSymmetry.calculateSymmetry(Creature.model);\n  //Simulator.print(\"Estimated planar symmetry of '%s' for parameters (%g,%g,%g) is %g%%\" % Creature.name % ModelSymmetry.symAlphaSteps % ModelSymmetry.symBetaSteps % ModelSymmetry.symPosSteps % symmetry*100); //could be printed in thater or gui, but theater's genotype viewer mode has neither CLI nor Simulator objects so we have no printing function\n  \n  //restore original parameters\n  ModelSymmetry.symAlphaSteps=olda;\n  ModelSymmetry.symBetaSteps=oldb;\n  ModelSymmetry.symPosSteps=oldp;\n\n  // createPlaneVertices([-0.305212, -0.939347, -0.156434], 0.0798513,\n  createPlaneVertices([ModelSymmetry.symResultA, ModelSymmetry.symResultB, ModelSymmetry.symResultC], ModelSymmetry.symResultD,\n      [minx, miny, minz], [maxx, maxy, maxz]);\n\n  VertexBuilder.addColor(0xbb9999ff); //0xbb=transparent (alpha)\n  VertexBuilder.twosided=1;\n  Material.new();\n  Material.setFlat();\n  Material.translucent = 1;\n  Material.colormat = GL.AMBIENT_AND_DIFFUSE;\n  Material.disable(GL.TEXTURE_2D);\n  Material.disable(GL.LIGHTING);\n  Material.enable(GL.BLEND);\n  VertexBuilder.material = Material.object;\n  GeomBuilder.currentNode = VisualModel.rootNode;\n  GeomBuilder.add(VertexBuilder.node);\n  }\n}\n\nfunction food_model_build()\n{\ndefault_model_build();\nif (Creature.numjoints==0)\n\tVisualModel.partshadow = VisProperties.shadows;\n}\n\nfunction manipulator_model_update()\n{}\n\nfunction updatetextlabel()\n{\nElement.useCreature();\nif (VisProperties.shownames)\nif (Creature.population)\n{\nvar tr=GeomBuilder.getBranch(VisualModel.rootNode,0);\nif (tr)\n\t{\n\tGeomBuilder.matrixReset();\n\tGeomBuilder.matrixMove(Creature.pos_x+Creature.size_x/2,Creature.pos_y+Creature.size_y/2,Creature.pos_z+Creature.size_z/2);\n\tGeomBuilder.setMatrix(tr);\n\t}\n}\n}\n\nfunction default_model_update()\n{\nElement.useCreature();\nif (Creature.energy0>0)\n  {\n  var e = Creature.energy / Creature.energy0;\n  if (e > 2.0)\n    e = 2.0;\n  else if (e < 0.05)\n    e = 0.05;\n  VisualModel.brightness=e;\n  }\nupdatetextlabel();\n}\n\nfunction food_model_update()\n{\nupdatetextlabel();\n}\n\nfunction mark_model_build() //marks are vertical signs (bars), used for example in maze experiments\n{\n  VisualModel.partshadow = 0.4*VisProperties.shadows;\n  var color=VisualModel.getArg(\"color\");\n  if (color!=\"\") VisualModel.color=color;\n}\n\nfunction mark_model_update()\n{}\n\nfunction boid_part_build()\n{\n  loadAndAddAsTransformNode(\"bird.ac\");\n}\n\nfunction default_part_build()\n{\nElement.useCreature();\nElement.usePart();\n\nswitch(p.sh)\n\t{\n\tcase 0:\n\tif (Creature.numjoints>0)\n\t\t{\n\t\tGeomBuilder.addTransform(GeomBuilder.rootNode);\n\t\tElement.node = GeomBuilder.currentNode;\n\t\t}\n\telse\n\t\tloadAndAddAsTransformNode(\"greenball.ac\");\n\tbreak;\n\n\tcase 1: //elipsoid\n\t\tloadAndAddAsTransformNode(\"greenball.ac\");\n\t\tVisualModel.partshadow = VisProperties.shadows;\n\t\tElement.shadow=1;\n\t\tbreak;\n\tcase 2: //cuboid\n\t\tloadAndAddAsTransformNode(\"boxpart_shape.ac\");\n\t\tVisualModel.partshadow = VisProperties.shadows;\n\t\tElement.shadow=1;\n\t\tbreak;\n\tcase 3: //cylinder\n\t\tloadAndAddAsTransformNode(\"cylpart_shape.ac\");\n\t\tVisualModel.partshadow = VisProperties.shadows;\n\t\tElement.shadow=1;\n\t\tbreak;\n\t}\n\nif (VisProperties.axes)\n   {\n   Loader.load(\"xyz.ac\");\n   if (Loader.loaded)\n      {\n      var sx=1.0,sy=1.0,sz=1.0;\n      GeomBuilder.addTransform(GeomBuilder.currentNode);\n      GeomBuilder.add(Loader.loaded);\n      if (p.sh)\n           { // the whole part element will be later re-scaled according to its shape scale, the transformation below partially counteracts this in order to get reasonable axes size\n\t   switch(p.sh)\n\t      {\n\t      case 1: sx=10.0*p.sx; sy=10.0*p.sy; sz=10.0*p.sz; break;\n\t      case 2: sx=p.sx; sy=p.sy; sz=p.sz; break;\n\t      case 3: sx=p.sx; sy=10.0*p.sy; sz=10.0*p.sz; break;\n\t      }\n\t   sx=Math.min(100.0,Math.max(0.01,sx));\n\t   sy=Math.min(100.0,Math.max(0.01,sy));\n\t   sz=Math.min(100.0,Math.max(0.01,sz));\n\t   GeomBuilder.matrixReset();\n\t   GeomBuilder.matrixScale(0.5/sx+0.5,0.5/sy+0.5,0.5/sz+0.5);\n\t   GeomBuilder.setMatrix(GeomBuilder.currentNode);\n\t   }\n      }\n   }\n\n}\n\nfunction loadAndAddAsTransformNode(filename)\n{\n  Loader.load(filename);\n  if (Loader.loaded)\n  {\n    GeomBuilder.addTransform(GeomBuilder.rootNode);\n    Element.node = GeomBuilder.currentNode;\n    GeomBuilder.add(Loader.loaded);\n  }\n}\n\nfunction manipulator_part_build()\n{\n  loadAndAddAsTransformNode(\"manip-close.ac\");\n}\n\nfunction default_joint_build()\n{\n  Element.useJoint();\n  if (j.sh==1)\n    { //solid/invisible\n    GeomBuilder.addTransform(GeomBuilder.rootNode);\n    Element.node = GeomBuilder.currentNode;\n    VisualModel.jointshadow = 0;\n    }\n  else\n    {\n  Element.useJointPart1();\n  var as=p.as;\n  Element.useJointPart2();\n  as=(as+p.as)/2;\n  var stick;\n  if ((World.simtype==1)&&(ODE.odeshape==1))\n\tstick=\"boxstick_flat.ac\";\n  else\n\tstick=\"greenstick\" + int(1.0+4.999*as) + \".ac\";\n  loadAndAddAsTransformNode(stick);\n    }\n}\n\nfunction default_part_update()\n{\n  Element.useMechPart();\n  Element.usePart();\n  GeomBuilder.matrixReset();\n  GeomBuilder.matrixPosition1(MechPart.pos);\n  GeomBuilder.matrixOrient1(MechPart.orient);\n  switch(p.sh)\n    {\n    case 1: //ellipsoid\n      GeomBuilder.matrixScale(p.sx/0.2, p.sy/0.2, p.sz/0.2);\n      break;\n    case 2: //cuboid\n      GeomBuilder.matrixScale(p.sx, p.sy, p.sz);\n      break;\n    case 3: //cylinder\n      GeomBuilder.matrixScale(p.sx, p.sy/0.2, p.sz/0.2);\n      break;\n    }\n  GeomBuilder.setMatrix(Element.node);\n}\n\nfunction food_part_build()\n{\nvar file=\"apple.ac\";\nvar color=VisualModel.getArg(\"color\");\nif (color!=\"\") { file=\"applewhite.ac\"; VisualModel.color=color; }\nloadAndAddAsTransformNode(file);\n}\n\nfunction food_part_update()\n{\n  Element.useCreature();\n  var e;\n  if (Creature.energy0>0)\n   {\n   e = Creature.energy / Creature.energy0;\n   if (e > 1.0)\n    e = 1.0;\n   else if (e < 0.05)\n    e = 0.05;\n   }\n  else e=1.0;\n  Element.useMechPart();\n  GeomBuilder.matrixReset();\n  if (World.simtype==0) GeomBuilder.matrixMove(0,0,-0.2);\n  else GeomBuilder.matrixMove(0,0,-(1.0-e)*0.8);\n  GeomBuilder.matrixMove1(MechPart.pos);\n  GeomBuilder.matrixOrient1(MechPart.orient);\n  if (e!=1.0) GeomBuilder.matrixScale(e, e, e);\n  if (World.simtype==1) GeomBuilder.matrixMove(0,0,-0.8);\n  GeomBuilder.setMatrix(Element.node);\n  VisualModel.partshadow = e*VisProperties.shadows;\n}\n\nfunction mark_part_build()\n{\n  loadAndAddAsTransformNode(\"cube.ac\");\n}\n\nfunction mark_part_update()\n{\n  Element.useMechPart();\n  GeomBuilder.matrixReset();\n  GeomBuilder.matrixMove1(MechPart.pos);\n  GeomBuilder.matrixMove(0,0,2);\n  GeomBuilder.matrixOrient1(MechPart.orient);\n  Element.useCreature();\n  GeomBuilder.matrixScale(0.3, 0.3, 3.0);\n  GeomBuilder.setMatrix(Element.node);\n}\n\nfunction default_joint_update()\n{\n  Element.useJoint();\n  if (j.sh==1) return;\n  Element.useMechJointPart1();\n  Element.useMechJoint();\n  GeomBuilder.matrixReset();\n  if ((World.simtype==1)&&(ODE.odeshape==1))\n\t{\n  GeomBuilder.matrixOrient1(MechJoint.calcorient);\n  GeomBuilder.matrixMove(MechPart.x-GeomBuilder.matrix00*0.2,MechPart.y-GeomBuilder.matrix01*0.2,MechPart.z-GeomBuilder.matrix02*0.2);\n  GeomBuilder.matrixScale(MechJoint.length+0.4, 1, 1);\n\t}\n  else\n\t{\n  GeomBuilder.matrixMove1(MechPart.pos);\n  GeomBuilder.matrixOrient1(MechJoint.calcorient);\n  var width=0.01*VisProperties.joint_width;\n  GeomBuilder.matrixScale(MechJoint.length,width,width);\n        }\n  GeomBuilder.setMatrix(Element.node);\n}\n\nfunction setScenePanorama(which)\n{\n  Scene.worldtexture = [\"\", \"field_.png\", \"ocean_.png\", \"darkcity_.png\"][which];\n}\n\nfunction world_build()\n{\n  Scene.backcolor = VisProperties.worldbgcolor;\n  setScenePanorama(VisProperties.worldpan);\n\n  if (VisProperties.hideworld) return;\n\n  switch (World.wrldtyp)\n  {\n  case 0:\n    buildFlatWorld();\n    break;\n  case 1:\n    buildBlockWorld();\n    break;\n  case 2:\n    buildSmoothWorld();\n  }\n\n  if (World.wrldbnd == 0)\n  {\n    buildFlatBoundary();\n  }\n  else\n  {\n    Loader.load(\"flyingworld3.ac\");\n    if (Loader.loaded==null)\n      return ;\n    GeomBuilder.addTransform(GeomBuilder.rootNode);\n    GeomBuilder.matrixReset();\n    var siz = World.wrldsiz / 20.0;\n    GeomBuilder.matrixScale(siz, siz, siz);\n    var z=-0.2;\n    if (World.simtype) z=0.0;\n    GeomBuilder.matrixMove(0, 0, z);\n    GeomBuilder.setMatrix(GeomBuilder.currentNode);\n    GeomBuilder.add(Loader.loaded);\n  }\n\n}\n\n@include \"stdblocks.inc\"\n@include \"stdsmooth.inc\"\n@include \"stdboundary.inc\"\n\nfunction buildFlatWorld()\n{\n  GeomBuilder.addBranch(GeomBuilder.rootNode);\n  VertexBuilder.newQuads();\n  var z = -0.2;\n  if (World.simtype) z=0.0;\n  VertexBuilder.addVertex([0.0, 0.0, z, World.wrldsiz, 0.0, z,\n                           World.wrldsiz, World.wrldsiz, z, 0.0, World.wrldsiz, z]);\n  VertexBuilder.addColor(0.85, 0.75, 0.55);\n  VertexBuilder.addNormal(0, 0, 1);\n  VertexBuilder.twosided=1;\n  Material.new();\n  Material.setFlat();\n  Material.disable(GL.TEXTURE_2D);\n  Material.disable(GL.BLEND);\n  Material.enable(GL.LIGHTING);\n  Material.enable(GL.COLOR_MATERIAL);\n  Material.colormat=GL.AMBIENT_AND_DIFFUSE;\n  Material.specular = 0;\n  VertexBuilder.material = Material.object;\n  GeomBuilder.add(VertexBuilder.node);\n  buildWorldBoundary();\n  buildWorldWater();\n}\n\nfunction buildFlatBoundary()\n{\n  var ma = World.wrldsiz * 2;\n  var mi = 0.0 - World.wrldsiz;\n  var si = World.wrldsiz;\n  var z = -0.2;\n  if (World.simtype) z=0.0;\n  GeomBuilder.addBranch(GeomBuilder.rootNode);\n  VertexBuilder.newQuads();\n  VertexBuilder.addVertex([si, 0.0, z, ma, 0.0, z, ma, si, z, si, si, z,\n                           0.0, si, z, si, si, z, si, ma, z, 0.0, ma, z,\n                           mi, 0.0, z, 0.0, 0.0, z, 0.0, si, z, mi, si, z,\n                           0.0, mi, z, si, mi, z, si, 0.0, z, 0.0, 0.0, z]);\n  VertexBuilder.addColor(0.80, 0.70, 0.50);\n  VertexBuilder.addNormal(0, 0, 1);\n  VertexBuilder.twosided=1;\n  Material.new();\n  Material.setFlat();\n  Material.specular = 0;\n  Material.disable(GL.TEXTURE_2D);\n  VertexBuilder.material = Material.object;\n\n  GeomBuilder.add(VertexBuilder.node);\n  GeomBuilder.addBranch(GeomBuilder.rootNode);\n  VertexBuilder.newQuads();\n  VertexBuilder.addVertex([si, si, z, ma, si, z, ma, ma, z, si, ma, z,\n                           si, mi, z, ma, mi, z, ma, 0.0, z, si, 0.0, z,\n                           mi, si, z, 0.0, si, z, 0.0, ma, z, mi, ma, z,\n                           mi, mi, z, 0.0, mi, z, 0.0, 0.0, z, mi, 0.0, z]);\n  VertexBuilder.addColor(0.85, 0.75, 0.55);\n  VertexBuilder.addNormal(0, 0, 1);\n  VertexBuilder.twosided=1;\n  Material.new();\n  Material.setFlat();\n  Material.disable(GL.TEXTURE_2D);\n  Material.specular = 0;\n  VertexBuilder.material = Material.object;\n  GeomBuilder.add(VertexBuilder.node);\n}\n\nfunction buildWorldWater()\n{\n  if (World.wrldwat < -5.0)\n    return ;\n  var mi = 0.0, ma = World.wrldsiz;\n  var z = World.wrldwat;\n  if (World.simtype==0) z-=0.2;\n  if (World.wrldbnd == 0)\n  {\n    mi -= ma;\n    ma += ma;\n  }\n  else\n  {\n    if (z > 0.0)\n    {\n      var z2=z+1.0;\n      GeomBuilder.addBranch(GeomBuilder.rootNode);\n      VertexBuilder.newLines();\n      VertexBuilder.addVertex([mi, mi, z2, ma, mi, z2, ma, mi, z2, ma, ma, z2,\n                               ma, ma, z2, mi, ma, z2, mi, ma, z2, mi, mi, z2,\n                               mi, mi, z2, mi, mi, mi, mi, ma, z2, mi, ma, mi,\n                               ma, ma, z2, ma, ma, mi, ma, mi, z2, ma, mi, mi]);\n      VertexBuilder.addColor(0xff000000);\n      Material.new();\n      Material.setFlat();\n      Material.disable(GL.TEXTURE_2D);\n      Material.disable(GL.LIGHTING);\n      Material.colormat = GL.AMBIENT_AND_DIFFUSE;\n      VertexBuilder.material = Material.object;\n      GeomBuilder.add(VertexBuilder.node);\n    }\n  }\n  GeomBuilder.addBranch(GeomBuilder.rootNode);\n  VertexBuilder.newQuads();\n  VertexBuilder.addVertex([mi, mi, z, ma, mi, z, ma, ma, z, mi, ma, z]);\n  VertexBuilder.addNormal(0.0, 0.0, 1.0);\n  VertexBuilder.addColor(0x80ff8833);\n  VertexBuilder.genTexCoordsXY(0.17, 0.17);\n  VertexBuilder.twosided=1;\n  Material.new();\n  Material.setFlat();\n  Material.enable(GL.TEXTURE_2D);\n  Material.enable(GL.BLEND);\n  Material.enable(GL.COLOR_MATERIAL);\n  Material.disable(GL.LIGHTING);\n  Material.translucent = 1;\n  Material.texture = \"waves.png\";\n  VertexBuilder.material = Material.object;\n  GeomBuilder.add(VertexBuilder.node);\n}\n\nfunction VisProperties_set()\n{\n  VisualStyle.rebuild();\n}\n\nfunction modelviewer_build_empty()\n{\n  Scene.backcolor = VisProperties.bgcolor;\n  setScenePanorama(VisProperties.modelpan);\n}\n\n// min.x/y/z = s6/5/4   max.x/y/z = s3/2/1\nfunction modelviewer_build(minx, miny, minz, maxx, maxy, maxz)\n{\n  Scene.backcolor = VisProperties.bgcolor;\n  setScenePanorama(VisProperties.modelpan);\n  if (VisProperties.bbox)\n  {\n  VertexBuilder.newQuads();\n  VertexBuilder.addVertex([minx, miny, minz, maxx, miny, minz, maxx, maxy, minz, minx, maxy, minz]);\n  VertexBuilder.twosided=1;\n  Material.new();\n  Material.setFlat();\n  Material.colormat = GL.AMBIENT_AND_DIFFUSE;\n  Material.disable(GL.TEXTURE_2D);\n  Material.disable(GL.LIGHTING);\n  VertexBuilder.material = Material.object;\n  GeomBuilder.add(VertexBuilder.node);\n  VertexBuilder.newLines();\n  VertexBuilder.addVertex([minx, miny, minz, minx, miny, maxz, minx, miny, maxz, maxx, miny, maxz,\n                           maxx, miny, maxz, maxx, miny, minz, minx, maxy, minz, minx, maxy, maxz,\n                           minx, maxy, maxz, maxx, maxy, maxz, maxx, maxy, maxz, maxx, maxy, minz,\n                           minx, miny, maxz, minx, maxy, maxz, maxx, miny, maxz, maxx, maxy, maxz]);\n  VertexBuilder.addColor(0xff000000);\n  GeomBuilder.add(VertexBuilder.node);\n  }\n}\n"
  },
  {
    "id": "worldpan",
    "_classname": "property",
    "type": "d 0 3 2 ~None~Field~Ocean~Dark city",
    "name": "World panorama"
  },
  {
    "id": "worldbgcolor",
    "_classname": "property",
    "type": "dc 0 16777215 16764040",
    "name": "World view background"
  },
  {
    "id": "hideworld",
    "_classname": "property",
    "help": "Can be useful for screenshots",
    "type": "d 0 1 0",
    "name": "Hide world objects except creatures"
  },
  {
    "id": "modelpan",
    "_classname": "property",
    "type": "d 0 3 1 ~Solid background~Field~Ocean~Dark city",
    "name": "Body view panorama"
  },
  {
    "id": "bgcolor",
    "_classname": "property",
    "type": "dc 0 16777215 16764040",
    "name": "Body view background"
  },
  {
    "id": "bbox",
    "_classname": "property",
    "type": "d 0 1 1",
    "name": "Body view bounding box"
  },
  {
    "id": "joint_width",
    "_classname": "property",
    "type": "d 10 150 100",
    "name": "Stick width (%)"
  },
  {
    "id": "shadows",
    "_classname": "property",
    "type": "d 0 1 1",
    "name": "Shadows"
  },
  {
    "id": "axes",
    "_classname": "property",
    "type": "d 0 1 0",
    "name": "X/Y/Z axes"
  },
  {
    "id": "shownames",
    "_classname": "property",
    "type": "d 0 1 0",
    "name": "Show names"
  },
  {
    "id": "symmetryplane",
    "_classname": "property",
    "help": "Displays a guess of the symmetry plane (may take a long time to compue for complex bodies).\nUse scripting and the ModelSymmetry class to compute symmetry accurately.\nDetails of the symmetry estimation procedure are described in http://www.framsticks.com/node/808",
    "type": "d 0 1 0",
    "name": "Guess symmetry plane (body view)"
  }
]